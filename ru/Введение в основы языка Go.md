### Введение в основы языка Go

**Оригинал статьи:** https://programmer.ink/think/introduction-to-go-language-foundation.html

**Опубликовано:** warydig, Пн, 07 мар 2022 13:04:59 +0100

Эта статья представляет собой краткий обзор основ языка Go и его синтаксических особенностей.

В отличие от `go build`, команда `go run` не создает исполняемый файл в текущей папке. Она компилирует и запускает программу "на лету", что удобно на этапе разработки. Для распространения готовой программы используется `go build`.

Изначально язык Go создавался для разработки высоконагруженных производственных систем.

В функциях, написанных на Go, необходимо объявлять типы параметров и возвращаемых значений.

```go
func addition(x int, y int) int {
    return x + y
}
```

Булевы значения могут быть только `true` и `false`, использование `0` и `1` в качестве булевых значений не допускается.

При объявлении массива необходимо указывать его длину и тип элементов.

```go
var bele [4]string

bele[0] = "john"
```

Пакет `strconv` предоставляет полный набор методов для преобразования типов (например, из строки в число и обратно).

Go самостоятельно управляет памятью: выделяет её и выполняет **сборку мусора** (garbage collection). Обычные правила эффективного использования памяти по-прежнему актуальны, но нет необходимости управлять памятью напрямую.

При объявлении переменной без присвоения ей значения, ей присваивается **нулевое значение** по умолчанию для её типа. Поэтому, чтобы определить, было ли переменной присвоено значение, нельзя проверять ее на `nil` (если это не тип, для которого `nil` является нулевым значением), а следует проверять на её нулевое значение.

Краткое объявление переменных (`:=`) нельзя использовать вне функций (на уровне пакета).

Используйте оператор `&` перед именем переменной, чтобы получить ее адрес в памяти.

```go
s := "Hello"

fmt.Println(&s) // Выведет шестнадцатеричный адрес переменной в памяти
```

Константы объявляются с помощью ключевого слова `const`.

```go
const greeting string = "Hello"
```

Функция может возвращать несколько значений, которые перечисляются через запятую. При получении этих значений их также нужно перечислять через запятую в том же порядке.

Функция может принимать переменное число аргументов (**вариативная функция**). Эти аргументы должны быть одного типа и должны быть последними в списке параметров.

```go
func sumNumbers(numbers... int) int {
    total := 0
    for _, number := range numbers {
        total += number
    }
    return total
}
```

**Именованные возвращаемые значения** позволяют присвоить значения переменным перед возвратом из функции.

```go
// func имя_функции(параметры) (имя_переменной тип) {
//     тело функции
//     имя_переменной = значение
//     return
// }

func bar(x, y int) (a, b, c int) { // Именованные возвращаемые значения
    a = x + y
    b = x - y
    c = x * y
    return // "Голый" возврат (naked return)
}

func main() {
    d, e := 13, 2
    fmt.Println(bar(d, e)) // Выведет: 15 11 26
}
```

**Рекурсивная функция** должна иметь как минимум два пути возврата: **базовый случай** (условие для прекращения рекурсии) и **рекурсивный шаг** (в котором функция вызывает саму себя).

Go рассматривает функции как тип данных. Поэтому можно присваивать функции переменным и вызывать их через эти переменные.

```go
func an(f func() string) string {
    return f()
}

func main() {
    fn := func() string {
        return "function called"
    }
    fmt.Println(an(fn)) // Выведет: function called
}
```

Оператор `switch` поддерживает ветку `default`, которая выполняется, если ни одно из условий `case` не удовлетворено.

```go
s := "c"

switch s {
case "a":
    fmt.Println("a")
case "b":
    fmt.Println("b")
default:
    fmt.Println("neither a nor b")
}
```

Оператор `for` с ключевым словом `range` используется для итерации по структурам данных.

```go
numbers := []int{1, 2, 3, 4} // Примечание: правильный синтаксис для слайса
for i, n := range numbers {
    fmt.Println("индекс:", i)
    fmt.Println("значение:", n)
}
```

Инструкция `defer` позволяет выполнить другую функцию непосредственно перед выходом из текущей функции.

```go
func main() {
    defer fmt.Println("1")
    fmt.Println("2")
}
// Вывод:
// 2
// 1
```

Чтобы напечатать все элементы массива или слайса, можно просто передать переменную в `fmt.Println`.

**Слайсы** (slices) похожи на массивы, но их размер может меняться: можно добавлять и удалять элементы.

```go
func main() {
    // Создаем слайс строк длиной 2
    che := make([]string, 2)
    che[0] = "1"
    che[1] = "2"

    // Добавляем элемент в конец слайса
    che = append(che, "3") // [1 2 3]

    // Удаляем элемент с индексом 2 (третий элемент)
    // Примечание: в оригинале была ошибка в этом примере, он удалял несуществующий элемент.
    // che = append(che[:1], che[2:]...) // Так удаляется элемент с индексом 1: [1 3]

    // Копируем один слайс в другой
    s := make([]string, len(che))
    copy(s, che)
}
```

**Карта** (`map`) — это коллекция пар "ключ-значение", аналог словаря в Python.

```go
var p = make(map[string]int)

p["c"] = 2
delete(p, "c")
```

**Структуры** (`struct`) позволяют хранить поля разных типов данных в одной переменной.

```go
type Movie struct {
    Name   string
    Rating float64
} // Определяем структуру Movie

var m Movie // Объявление переменной типа Movie

m2 := Movie{"Inception", 10.0} // Инициализация
```

При инициализации структуры с большим количеством полей рекомендуется указывать имена полей. Это улучшает читаемость и поддерживаемость кода. Важно отметить, что в этом случае запятая после последнего поля обязательна, если закрывающая скобка `}` находится на новой строке.

```go
m3 := Movie{
    Name:   "The Dark Knight",
    Rating: 9.5, // Обязательная запятая
}
```

Для доступа к полям вложенных структур используется точечная нотация (`.`).

#### Нулевые значения в Go

| Тип | Нулевое значение |
| :--- | :--- |
| `bool` | `false` |
| `int`, `float` | `0` |
| `string` | `""` (пустая строка) |
| Указатель | `nil` |
| Функция | `nil` |
| Интерфейс | `nil` |
| Слайс | `nil` |
| Канал | `nil` |
| Карта (`map`) | `nil` |

В Go нет встроенных конструкторов, как в других языках, но для создания экземпляров с пользовательскими значениями по умолчанию используется идиома с функцией-конструктором (обычно с префиксом `New...`).

```go
type Alarm struct {
    Time  string
    Sound string
}

// Функция-конструктор
func NewAlarm(time string) Alarm {
    a := Alarm{
        Time:  time,
        Sound: "klaxon", // Пользовательское значение по умолчанию
    }
    return a
}

// Вместо прямого создания Alarm, используем NewAlarm,
// чтобы поле Sound получило значение по умолчанию.
myAlarm := NewAlarm("07:00")
```

Структуры можно сравнивать с помощью оператора `==`, если их типы идентичны и все их поля сравнимы. Попытка сравнить структуры разных типов приведет к ошибке компиляции.

Чтобы экспортировать структуру и ее поля (сделать их доступными из других пакетов), их имена должны начинаться с заглавной буквы.

**Методы** — это функции, связанные с определенным типом. Любой экземпляр этого типа может вызывать его методы.

```go
type Movie struct {
    Name   string
    Rating float64
}

// sum — это метод для типа *Movie
func (m *Movie) GetInfo() string {
    // ... какой-то код
    return m.Name
}

m := Movie{"Interstellar", 9.8}
m.GetInfo() // Вызов метода
```

Любой тип данных может иметь связанный с ним набор методов. Это эффективный способ инкапсуляции функциональности и создания библиотечного кода.

Разница между **получателем-указателем** (`*Type`) и **получателем-значением** (`Type`) тонка, но выбор прост:
*   Используйте **указатель**, если вам нужно изменить исходную структуру.
*   Используйте **значение**, если вам нужно работать со структурой, но не изменять исходный экземпляр (создается копия).

**Интерфейс** (`interface`) описывает набор методов, которые тип должен реализовать, и указывает сигнатуры этих методов. Интерфейс — это "чертеж" набора методов. Чтобы тип удовлетворял интерфейсу, он должен реализовать все его методы.

Условие совпадения сигнатур: имя функции, типы, количество и порядок параметров и возвращаемых значений должны быть одинаковыми.

Интерфейс также является типом и может передаваться в качестве параметра в функцию.

В Go нет объектно-ориентированных возможностей, таких как классы и наследование, но структуры и методы восполняют этот недостаток, предоставляя некоторые элементы ООП.

Интерфейс обеспечивает **полиморфизм** декларативным способом. Поскольку интерфейс описывает набор методов, которые должны быть предоставлены, любой тип, реализующий этот интерфейс, может быть использован везде, где ожидается этот интерфейс.

Строго говоря, единственное различие между методом и функцией заключается в том, что у метода есть дополнительный параметр — **получатель** (receiver), который связывает его с определенным типом.