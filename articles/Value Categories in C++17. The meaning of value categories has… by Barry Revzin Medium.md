# Value Categories in C++17. The meaning of value categories has… | by Barry Revzin | Medium
[

![](https://miro.medium.com/v2/resize:fill:44:44/1*YPFtkxvEcaxBV1InrEnsXg.png)






](https://medium.com/@barryrevzin?source=post_page---byline--f56ae54bccbe---------------------------------------)

5 минут чтения

4 сентября 2017 г.

Значение категорий значений со временем менялось, и эта тема может быть довольно запутанной и приводить к неправильным представлениям. В этой статье мы постараемся объяснить, что на самом деле представляют собой эти странно названные вещи в C++17.

Самое важное, что нужно помнить, — это то, что категории значений — это таксономия _выражений_. Они не являются категориями объектов, переменных или типов. Если вы допустите ошибку, это сразу же приведёт к проблемам. Рассмотрим:

_Переменная_ `r` является ссылкой на _rvalue_. Но _выражение_ `r` в строке 5 является lvalue. Таким образом, вызывается #1. Неважно, что тип `r` совпадает (в точности) с #2. Несоответствие категории значений делает этот вариант непригодным.

Каждое выражение, от произвольных сложных до простых идентификаторов или литералов, относится к определённой категории. На мой взгляд, эту классификацию лучше всего представить в виде диаграммы Венна:

![](https://miro.medium.com/v2/resize:fit:700/1*G9HLBwBJFho9TNzE0J9__w.png)

То есть каждое выражение является либо _l-значением_, либо _x-значением_, либо _r-значением_. Эти три категории, в свою очередь, являются подмножествами двух более широких категорий значений: _gl-значений_ (объединение l-значений и x-значений) и _r-значений_ (объединение x-значений и r-значений). Помимо словесной путаницы, что на самом деле означают эти термины? В новом стандарте определения весьма полезны. Три ключевых из них взяты из [\[basic.lval\]](http://eel.is/c++draft/basic.lval) (остальные два определяются их положением на диаграмме Венна):

*   [_glvalue_](http://eel.is/c++draft/basic.lval#def:glvalue) — это выражение, результат вычисления которого определяет идентификатор объекта, битового поля или функции.
*   [_Правое значение_](http://eel.is/c++draft/basic.lval#def:prvalue) — это выражение, при вычислении которого инициализируется объект или битовое поле или вычисляется значение операнда оператора в соответствии с контекстом, в котором оно используется.
*   [_X-значение_](http://eel.is/c++draft/basic.lval#def:xvalue) — это gl-значение, обозначающее объект или битовое поле, ресурсы которого могут быть использованы повторно (обычно потому, что срок его службы подходит к концу).

Обычно эти категории описываются с помощью группировок более высокого уровня, которые характеризуются свойствами этих выражений. То есть:

![](https://miro.medium.com/v2/resize:fit:700/1*j-uvWhoJEfAoCwkWoUErRQ.png)

Я думаю, что это по-прежнему полезный способ мышления о категориях, даже если он уже не совсем точен. Часть «имеет идентичность» по-прежнему актуальна — на самом деле, стандартное определение _glvalue_ в основном соответствует этому критерию.

Но большая часть изменений в [P0135](https://wg21.link/p0135) («Гарантированное исключение копирования с помощью упрощённых категорий значений») заключается в том, что сами по себе pr-значения не обязательно должны приводить к существованию объектов (только если необходима «временная материализация»), и поэтому не имеет смысла говорить о том, можно ли безопасно повторно использовать эти ресурсы. Действительно, в C++17 pr-значения не перемещаются! Давайте рассмотрим, казалось бы, простой пример:

`T var = T();`

Для некоторого типа `T`. В C++03 выражение `T()` является rvalue, но это копирование-создание новой переменной с именем `var`. В C++11 выражение `T()` является prvalue, и это копирование-перемещение. В обоих случаях копирование/перемещение, скорее всего, будет опущено, даже если есть побочные эффекты. Однако в C++17 _перемещения нет_. Это важно повторить для наглядности. Prvalue _не перемещается из_. Это инициализация значения `var` и в точности эквивалентно:

`T var();`

(Или, по крайней мере, было бы, если бы вышеописанное не было объявлением функции. То, что `T var = T()` означает сегодня, — это объявление переменной `var` типа `T`, созданной с помощью инициализатора `()`. Это сложно выразить другими словами).

Разница может показаться незначительной. В чём разница между конструкцией перемещения, которую компилятор исключил, и просто отсутствием конструкции перемещения? Рассмотрим один из мотивирующих примеров P0135:

В C++14 этот код некорректен, и комментарии говорят сами за себя. Конструктор перемещения _должен быть допустимым_, даже если он вам не нужен. В C++17 это уже не так, и код работает нормально.

Самое важное — не запутаться в истории названий. Изначально две категории значений (l-значения и r-значения) были названы так потому, что эти выражения могли появляться в **л**евой или **р**авной части выражения присваивания. Но есть l-значения, которые не могут появляться в левой части присваивания (например, идентификатор, ссылающийся на `const` объект — такой объект нельзя присвоить), и есть r-значения, которые могут (например, при условии, что `struct S{};` выражение `S{} = S{}` корректно).

Категории значений отражаются в системе типов. Стандарт предлагает метод определения категории значения выражения с помощью `decltype`, как определено в [\[dcl.type.simple\]/4](http://eel.is/c++draft/dcl.type.simple#4). Учитывая выражение `expr`, мы можем определить тип `decltype((expr))` (дополнительные скобки _не_ являются опечаткой!). Если результирующий тип является ссылочным типом lvalue, то выражение является lvalue. Если результирующий тип является ссылочным типом rvalue, то выражение является xvalue. В противном случае (если результирующий тип не является ссылочным) выражение является prvalue.  Например:

Только r-значения могут привязываться к ссылкам на r-значения, только l-значения могут привязываться к ссылкам на _неконстантные_ l-значения (единственным исключением здесь является то, что r-значения действительно могут привязываться к ссылкам на константные l-значения, что Херб Саттер называет [самым важным const](https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/)). Это позволяет нам различать в системе типов l-значения и r-значения (чтобы было понятно, когда ресурсы объекта можно безопасно использовать повторно, а когда их нужно копировать), но нет способа [различать x-значения и pr-значения](https://medium.com/@barryrevzin/xvalues-and-prvalues-the-next-generation-10bd4b60a96a) при разрешении перегрузки. Действительно, такая дифференциация, вероятно, в любом случае не была бы полезной.

Подводя итог, можно сказать, что выражения в C++ делятся на пять пересекающихся категорий значений. gl-значения — это выражения, которые вычисляются для местоположений, они имеют идентификаторы. pr-значения используются для инициализации, они не обозначают объекты, но могут «материализовать» объект в тех случаях, когда это необходимо. x-значения — это gl-значения, которые обозначают объекты, срок жизни которых подходит к концу или которые иным образом помечены для повторного использования ресурсов. l-значения и x-значения имеют идентификаторы. x-значения можно безопасно перемещать. Псевдозначения, опять же, используются для инициализации. Категории значений — это категории выражений, а не объектов. Категории значений не связаны с присваиванием.