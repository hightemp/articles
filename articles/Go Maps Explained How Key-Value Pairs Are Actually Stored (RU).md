# Go Maps Explained: How Key-Value Pairs Are Actually Stored (RU)
![](https://victoriametrics.com/blog/go-map/go-map-preview.webp)

Карты Go Объяснили: Как на самом деле хранятся пары Ключ-значение

Если вы новичок в Go, вам может быть немного сложно понять, как использовать карты в Go. И даже если у вас есть опыт, понять, как на самом деле работают карты, может быть довольно сложно.

Возьмём, к примеру, такой вопрос: вы когда-нибудь задавали «подсказку» для карты и задумывались, почему она называется «подсказкой», а не чем-то простым, например, длиной, как в случае с отрезками?

Или, может быть, вы заметили, что при использовании цикла for-range для работы с картой порядок не соответствует порядку вставки, и он даже меняется, если вы выполняете цикл для одной и той же карты в разное время. Но, как ни странно, если вы выполняете цикл в одно и то же время, порядок обычно остаётся прежним.

Это долгая история, так что пристегните ремни и слушайте.

_Прежде чем мы продолжим, просто предупреждаю: представленная здесь информация основана на Go 1.23. Если что-то изменилось и это уже неактуально, не стесняйтесь писать мне на [X(@func25)](https://x.com/func25)._

Карта в Go: Быстрый старт [#](#map-in-go-quick-start)
-----------------------------------------------------

Итак, давайте поговорим о картах в Go. Это встроенный тип данных, который работает как хранилище «ключ-значение». В отличие от массивов, где ключи представляют собой возрастающие индексы, такие как 0, 1, 2 и так далее, в картах ключом может быть любой сопоставимый тип.

Это дает вам гораздо больше гибкости.

В этом примере мы создали пустую карту с помощью функции make(), где ключами являются строки, а значениями — целые числа.

![](https://victoriametrics.com/blog/go-map/map-simple.webp)

Карта \[«a»: 1, «b»: 2\]

Теперь вместо того, чтобы вручную присваивать значения каждому ключу, вы можете сэкономить время, используя литерал карты. Это позволяет задать пары «ключ-значение» сразу при создании карты:

Всё, что вам нужно сделать, — это перечислить ключи и их значения в фигурных скобках при первом создании карты. Это очень просто.

А если позже вы поймёте, что вам больше не нужна определённая пара «ключ-значение», Go поможет вам. Есть удобная функция удаления, которая удаляет ненужный вам ключ: `delete(m, "a")`.

Нулевое значение карты — это `nil`, а нулевая карта в некотором смысле похожа на пустую карту. Вы можете попытаться найти в ней ключи, и Go не выйдет из строя и не остановит вашу программу.

Если вы ищете ключ, которого нет, Go просто выдаст вам «нулевое значение» для типа значения этой карты:

Но вот в чём дело: вы не можете добавлять новые пары «ключ-значение» в пустую карту.

На самом деле, Go обрабатывает карты примерно так же, как и срезы. И карты, и срезы изначально имеют значение `nil`, и Go не паникует, если вы делаете с ними что-то «безобидное», пока они имеют значение nil. Например, вы можете перебирать срезы с нулевым значением без каких-либо «проблем».

Итак, что произойдет, если вы попытаетесь выполнить цикл по нулевой карте?

Ничего не происходит, никаких ошибок, никаких сюрпризов. Он просто спокойно ничего не делает.

Подход Go заключается в том, чтобы рассматривать значение по умолчанию для любого типа как что-то полезное, а не как то, что может привести к сбою программы. Go выдаёт ошибку только в том случае, если вы делаете что-то действительно незаконное, например, пытаетесь добавить новую пару «ключ-значение» в пустую карту или обращаетесь к индексу за пределами массива.

Есть еще пара вещей, которые вам следует знать о картах в Go:

*   Цикл for-range по карте не возвращает ключи в каком-либо определённом порядке.
*   Карты не являются потокобезопасными, и среда выполнения Go выдаст фатальную ошибку, если вы попытаетесь одновременно считывать (или перебирать с помощью for-range) и записывать данные в одну и ту же карту.
*   Вы можете проверить, есть ли ключ в карте, выполнив простую проверку `ok`: `_, ok := m[key]`.
*   Тип ключа для карты должен быть сопоставимым.

Давайте подробнее рассмотрим последний пункт о ключах карты. Ранее я упоминал, что «ключ может быть любого сопоставимого типа», но это не совсем так.

> _— Итак, что именно является сопоставимым типом? А что нет?_

Всё довольно просто: если вы можете использовать `==` для сравнения двух значений одного типа, то этот тип считается сопоставимым.

Но, как видите, приведенный выше код даже не компилируется. Компилятор выдает сообщение: _«недопустимая операция: s == s (map можно сравнивать только с nil)»._

Это же правило применимо к другим несопоставимым типам, таким как срезы, функции, структуры, содержащие срезы или карты, и т. д. Поэтому, если вы пытаетесь использовать любой из этих типов в качестве ключей в карте, вам не повезло.

Но есть маленький секрет: интерфейсы могут быть как сопоставимыми, так и несопоставимыми.

Что это значит? Вы можете без проблем определить карту с пустым интерфейсом в качестве ключа. Но будьте осторожны, есть большая вероятность, что вы столкнётесь с ошибкой во время выполнения.

Всё выглядит нормально, пока вы не попытаетесь использовать несопоставимый тип в качестве ключа карты.

В этом случае вы столкнётесь с ошибкой во время выполнения, с которой сложнее справиться, чем с ошибкой во время компиляции. Поэтому обычно рекомендуется избегать использования `interface{}` в качестве ключа карты, если у вас нет веской причины и ограничений, предотвращающих неправильное использование.

Но это сообщение об ошибке: _«хэш нехешируемого типа \[\]int»_ может показаться немного загадочным. Что это за хэш? Что ж, это повод разобраться в том, как Go работает «под капотом».

Анатомия карты [#](#map-anatomy)
--------------------------------

_При объяснении внутреннего устройства чего-то вроде карты легко увязнуть в мельчайших деталях исходного кода Go. Но мы постараемся сделать всё просто и понятно, чтобы даже новички в Go могли следить за ходом повествования._

То, что вы видите в коде Go как единую карту, на самом деле является абстракцией, которая скрывает сложные детали организации данных. На самом деле карта Go состоит из множества более мелких единиц, называемых «ведрами».

Посмотрите на исходный код Go выше: карта содержит указатель, который указывает на массив сегментов.

Вот почему, когда вы присваиваете карту переменной или передаёте её в функцию, и переменная, и аргумент функции ссылаются на один и тот же указатель карты.

Но не стоит путаться: карты — это указатели на `hmap` внутри, но они не являются ссылочными типами и не передаются по ссылке, как аргумент `ref` в C#. Если вы измените всю карту `m2`, это не отразится на исходной карте `m1` в вызывающей стороне.

В Go всё передаётся по значению. На самом деле происходит немного другое: когда вы передаёте карту `m1` в функцию `changeMap`, Go создаёт копию структуры `*hmap`. Таким образом, `m1` в `main()` и `m2` в функции `changeMap()` технически являются разными указателями, указывающими на один и тот же `hmap`.

![](https://victoriametrics.com/blog/go-map/map-value-type.webp)

Карта передается по значению

Подробнее об этом можно прочитать в отличной статье Дэйва Чейни под названием [«В Go нет передачи по ссылке»](https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go).

В каждом из этих сегментов может храниться не более 8 пар «ключ-значение», как показано на изображении ниже.

![](https://victoriametrics.com/blog/go-map/map-buckets.webp)

Фрагменты карты

На карте выше есть 2 блока, а `len(map)` равно 6.

Таким образом, когда вы добавляете пару «ключ-значение» на карту, Go не просто добавляет её случайным образом или последовательно. Вместо этого он помещает пару в одно из этих сегментов на основе хэш-значения ключа, которое определяется с помощью `hash(key, seed)`.

Давайте рассмотрим самый простой сценарий присвоения на изображении ниже, когда у нас есть пустая карта и мы присваиваем ей пару «ключ-значение» `"hello": 1`.

![](https://victoriametrics.com/blog/go-map/map-assignment.webp)

Назначьте пару ключ-значение пустой карте

Сначала он преобразует «привет» в число, затем берёт это число и делит его на количество сегментов.

Поскольку у нас здесь только одно ведро, любое число по модулю 1 равно 0, поэтому оно сразу попадает в ведро 0, и то же самое происходит, когда вы добавляете ещё одну пару «ключ-значение». Оно попытается поместить его в ведро 0, и если первый слот занят или имеет другой ключ, оно переместится в следующий слот в этом ведре.

Взгляните на `hash(key, seed)`: если вы используете цикл for-range для двух карт с одинаковыми ключами, вы можете заметить, что ключи выводятся в другом порядке:

Как это возможно? Разве ключ “a” на карте a и ключ “a” на карте b не хэшируются одинаково?

Но вот в чём дело: хотя хеш-функция, используемая для карт в Go, одинакова для всех карт с **одинаковым типом ключа**, `seed` используемая этой хеш-функцией, отличается для каждого экземпляра карты. Поэтому при создании новой карты Go генерирует случайное начальное значение только для этой карты.

В приведённом выше примере и `a` и `b` используют одну и ту же хеш-функцию, потому что их ключи относятся к типу `string`, но у каждой карты есть своё уникальное начальное значение.

> _— Подождите, в ведёрке всего 8 ячеек? Что будет, если ведро заполнится? Оно вырастет, как кусок пирога?_

Ну, в некотором роде. Когда корзины начинают заполняться или даже почти заполняются, в зависимости от того, как алгоритм определяет «заполнение», карта запускает процесс роста, который может удвоить количество основных корзин.

Но вот тут-то все становится немного интереснее.

Когда я говорю «основные сегменты», я имею в виду другое понятие: «переполненные сегменты». Они вступают в игру, когда возникает ситуация с большим количеством коллизий. Представьте, что у вас есть 4 сегмента, но один из них полностью заполнен 8 парами «ключ-значение» из-за большого количества коллизий, в то время как остальные 3 сегмента пусты.

![](https://victoriametrics.com/blog/go-map/map-overflow.webp)

Сильное столкновение на ковше 0

Вам действительно нужно увеличивать карту до 8 сегментов только потому, что вам нужно добавить ещё одну запись, которая, к сожалению, тоже попадает в первое полное сегменту?

Конечно, нет, верно? В таком случае было бы довольно расточительно удваивать количество ведер.

Вместо этого Go обрабатывает данные более эффективно, создавая «дополнительные корзины», которые связаны с первой корзиной. Новая пара «ключ-значение» сохраняется в этой дополнительной корзине, а не в основной.

![](https://victoriametrics.com/blog/go-map/map-overflow-2.webp)

Области переполнения карты

Карта в Go увеличивается, когда выполняется одно из двух условий: либо существует слишком много переполненных ячеек, либо карта перегружена, то есть коэффициент загрузки слишком высок.

Из-за этих двух условий существует также два вида роста:

*   Тот, который удваивает размер ведер (при перегрузке)
*   Тот, который сохраняет тот же размер, но перераспределяет записи (когда появляется слишком много переполненных сегментов).

Если существует слишком много переполненных сегментов, лучше перераспределить записи, а не просто добавить больше памяти.

В настоящее время коэффициент загрузки Go установлен на уровне 6,5. Это означает, что карта рассчитана на хранение в среднем 6,5 элементов в каждом сегменте, что составляет около 80% от максимальной ёмкости. Когда коэффициент загрузки превышает этот порог, карта считается перегруженной. В этом случае она будет расширяться за счёт выделения нового массива сегментов, который в два раза больше текущего, а затем перераспределения элементов в эти новые сегменты.

Причина, по которой нам нужно увеличивать размер карты, даже если корзина почти заполнена, связана с производительностью. Обычно мы думаем, что доступ к значениям на карте и их присвоение — это O(1), верно? Но не всегда всё так просто.

![](https://victoriametrics.com/blog/go-map/map-optimization.webp)

Операции с картой выполняются медленно при высокой коллизии

Чем больше мест в корзине занято, тем медленнее продвигается процесс.

Когда вы хотите добавить ещё одну пару «ключ-значение», нужно не просто проверить, есть ли место в корзине, а сравнить ключ с каждым существующим ключом в этой корзине, чтобы решить, добавляете ли вы новую запись или обновляете существующую.

И ситуация становится ещё хуже, когда у вас есть переполненные корзины, потому что тогда вам приходится проверять каждый слот в этих переполненных корзинах. Это замедление также влияет на операции доступа и удаления.

Но команда Go вас поддержала, они оптимизировали это сравнение для нас.

Помните хэш, который мы получили при хешировании ключа «Привет»? Go не просто отбрасывает его. На самом деле он кэширует хэш «Привет» в виде `uint8` и использует его для быстрого сравнения с хэшем любого нового ключа. Это делает первоначальную проверку очень быстрой.

![](https://victoriametrics.com/blog/go-map/map-tophash.webp)

Верхний хэш карты

Если после сравнения `tophash` они совпадают, это означает, что ключи «могут» быть одинаковыми. Затем Go переходит к более медленному процессу проверки, действительно ли ключи идентичны.

> _«Почему при создании новой карты с помощью функции make(map, hint) указывается не точный размер, а только подсказка?»_

К этому моменту вы, вероятно, уже готовы ответить на этот вопрос. Параметр `hint` в `make(map, hint)` сообщает Go, какое количество элементов **вы ожидаете** в карте.

Эта подсказка помогает сократить количество раз, когда карту нужно увеличивать по мере добавления элементов.

Поскольку каждая операция увеличения объёма требует выделения нового массива сегментов и копирования существующих элементов, это не самый эффективный процесс. Если начать с большей начальной ёмкости, можно избежать некоторых из этих дорогостоящих операций увеличения объёма.

Давайте посмотрим, как на самом деле увеличивается размер корзины по мере добавления новых элементов:

| Диапазон Подсказок | Количество ведер | Вместимость |
| --- | --- | --- |
| 0 - 8 | 1 | 8 |
| 9 - 13 | 2 | 16 |
| 14 - 26 | 4 | 32 |
| 27 - 52 | 8 | 64 |
| 53 - 104 | 16 | 128 |
| 105 - 208 | 32 | 256 |
| 209 - 416 | 64 | 512 |
| 417 - 832 | 128 | 1024 |
| 833 - 1664 | 256 | 2048 |

> _«Почему при указании 14 результатов получается 4 корзины? Нам нужно всего 2 корзины, чтобы охватить 14 записей»._

Именно здесь в игру вступает коэффициент нагрузки. Помните, что порог коэффициента нагрузки составляет 6,5? Он напрямую влияет на то, когда карта должна увеличиться.

*   В подсказке 13 у нас есть 2 корзины, и коэффициент загрузки составляет 13/2 = 6,5, что соответствует пороговому значению, но не превышает его. Таким образом, когда вы перейдёте к подсказке 14, коэффициент загрузки превысит 6,5, что приведёт к необходимости расширения.
*   То же самое относится к подсказке 26. При 4 сегментах коэффициент загрузки составляет 26/4 = 6,5, что снова соответствует пороговому значению. Когда вы переходите за пределы 26, карта должна расширяться, чтобы эффективно вмещать больше элементов.

По сути, во втором диапазоне вы можете видеть, что диапазон подсказок удваивается по сравнению с предыдущим, как и количество сегментов и их ёмкость.

Эвакуация при Выращивании [#](#evacuation-when-growing)
-------------------------------------------------------

Как мы уже говорили ранее, эвакуация не всегда означает удвоение размера сегментов. Если сегментов переполнения слишком много, эвакуация всё равно произойдёт, но новый массив сегментов будет того же размера, что и старый.

Более интересный сценарий — когда размер корзины удваивается, поэтому давайте сосредоточимся на нём.

Рост карты отвечает на два распространённых вопроса: «Почему нельзя получить адрес элемента карты?» и «Почему порядок for-range не гарантируется в разное время?»

Когда карта увеличивается, она выделяет новый массив сегментов, который в два раза больше старого. Все позиции в старых сегментах становятся недействительными, и их нужно переместить в новые сегменты с новыми адресами памяти.

![](https://victoriametrics.com/blog/go-map/map-evacuation.webp)

Эвакуация по карте

Дело в том, что если на вашей карте, скажем, 1000 пар «ключ-значение», то перемещение всех этих ключей сразу будет довольно затратной операцией, которая может блокировать вашу горутину на заметное время. Чтобы избежать этого, Go использует «постепенный рост», при котором за раз пересоздаётся только часть элементов.

Таким образом, процесс растягивается во времени, и ваша программа продолжает работать без сбоев и внезапных задержек.

Процесс становится немного сложнее, потому что нам нужно поддерживать целостность карты при чтении, записи, удалении или повторении операций, управляя при этом как старыми, так и новыми сегментами.

> _“Когда происходит постепенный рост?”_

Существует только два сценария, при которых происходит постепенный рост: когда вы добавляете пару «ключ-значение» на карту или когда вы удаляете ключ с карты. Любое из этих действий запускает процесс перемещения, и по крайней мере одно ведро перемещается в новый массив.

Когда вы присваиваете что-то вроде `m["Hello"] = 2`, если карта находится в процессе расширения, в первую очередь она удаляет старое ведро, содержащее ключ `Hello`.

Каждый элемент из старого набора данных перемещается в одно из двух новых наборов данных, и этот процесс применяется даже в том случае, если на карте более двух наборов данных.

![](https://victoriametrics.com/blog/go-map/map-evacuation-key.webp)

Клавиша "Привет" может переместиться в любое из двух новых ведер

Например, если вы увеличиваете количество сегментов с 4 до 8, элементы из старого `bucket 1` либо переместятся в новый `bucket 1`, либо в новый `bucket 5`. Откуда мы это знаем? Это просто немного математики с побитовой операцией.

Если a `hash % 4 == 1`, это означает `hash % 8 == 1` или `hash % 8 == 5`. Потому что для старого ведра, где `H % 4 == 1`, последние два бита `H` являются `01`. Когда мы рассматриваем последние три бита для нового массива bucket,:

*   Если третий бит (справа) равен 0, то последние три бита равны 001, что означает `H % 8 == 1`.
*   Если третий бит (справа) равен 1, то последние три бита равны 010, что означает `H % 8 == 5`.

![](https://victoriametrics.com/blog/go-map/map-evacuation-2.webp)

Сколько старого ведра откачивается

Если в старом контейнере есть дополнительные контейнеры, карта также перемещает элементы из этих дополнительных контейнеров в новые. После перемещения всех элементов карта помечает старый контейнер как «освобождённый» с помощью поля `tophash`.

На этом мы закончим сегодняшнюю дискуссию. Карта Go на самом деле сложнее, чем кажется, и содержит множество мелких деталей, о которых мы здесь не упоминаем. Например, топографическая карта используется не только для сравнения, но и для эвакуации.

Оставайтесь на связи [#](#stay-connected)
-----------------------------------------

Привет, я Фуонг Ле, инженер-программист в VictoriaMetrics. В приведённом выше тексте упор сделан на ясность и простоту, концепции объясняются так, чтобы их было легко понять, даже если они не всегда соответствуют академической точности.

Если вы заметите что-то устаревшее или у вас возникнут вопросы, не стесняйтесь обращаться ко мне. Вы можете написать мне в личные сообщения на [X(@func25)](https://twitter.com/func25).

Некоторые другие сообщения, которые могут вас заинтересовать:

*   [Считыватели, записывающие устройства и данные ввода-вывода находятся в движении.](https://victoriametrics.com/blog/go-io-reader-writer)
*   [Ломтики в готовом виде: Вырастите большими или идите домой](https://victoriametrics.com/blog/go-slice)
*   [Мьютекс Go Sync: Обычный режим и режим голодания](https://victoriametrics.com/blog/go-sync-mutex)
*   [Переходите к откладыванию: От базового к ловушкам](https://victoriametrics.com/blog/defer-in-go)
*   [Как работают массивы Go и как усложняется работа с For-Range](https://victoriametrics.com/blog/go-array)
*   [Уникальный пакет Inside Go: Упрощено интернирование строк](https://victoriametrics.com/blog/go-unique-package-intern-string)
*   [Вендоринг, или go mod vendor: что это?](https://victoriametrics.com/blog/vendoring-go-mod-vendor)

Кто Мы Такие [#](#who-we-are)
-----------------------------

Если вы хотите отслеживать работу своих сервисов, показатели и видеть, как всё работает, возможно, вам стоит обратить внимание на [VictoriaMetrics](https://docs.victoriametrics.com/). Это быстрый, **бесплатный** и экономичный способ следить за своей инфраструктурой.

А мы — суслики, энтузиасты, которые любят исследовать, экспериментировать и делиться знаниями о Go и его экосистеме.