# TCP/IP in Action | Gerry’s blog
*   [TCP 状态变化](#tcp-状态变化)
*   [Основная идея TCP: накопительный ответ с повторной передачей](#tcp-核心思想带重传的累积正向应答)
*   [Главное правило правильного использования TCP/IP: не создавайте путаницу](#正确使用-tcpip-首要原则别添乱)
*   [Заголовок IPv4](#ipv4-header)
*   [Заголовок TCP](#tcp-header)
*   [Сетевой адрес](#network-address)
*   [Структура данных](#datastruct)
    *   [sockaddr\_in](#sockaddr_in)
    *   [хостент](#hostent)
    *   [аддринфо](#addrinfo)
*   [Опции (розетка)](#options-socket)
*   [Интерфейс](#interface)
    *   [Контакты](#connect)
    *   [неблокирующее подключение](#non-blocking-connect)
    *   [Отправить](#send)
    *   [recv](#recv)
    *   [выберите](#select)
    *   [опрос](#poll)
    *   [getsockopt](#getsockopt)
    *   [getaddrinfo](#getaddrinfo)
    *   [gethostbyname - имя хоста](#gethostbyname)
    *   [получитеимя](#getpeername)
    *   [эполл](#epoll)
    *   [epoll\_ctl](#epoll_ctl)
*   [Нэгл 算法](#nagle-算法)
*   [Инструменты](#tools)
    *   [Простая проверка](#easeprobe)
*   [Q&A](#qa)
    *   [Как преобразовать строку в IP-адрес и наоборот](#how-to-convert-string-to-ip-address-and-vice-versa)
    *   [Когда требуется параметр TCP SO\_LINGER (0)?](#when-is-tcp-option-so_linger-0-required)
*   [Ссылаться](#refer)

![](http://blog.gerryyang.com/assets/images/202408/tcp_state.png)

TCP关闭连接如上图下半部分的四次握手实现。发起终止的一方称主动关闭（client），响应的一方为被动关闭（server）。

1.  Когда клиент хочет завершить работу, он отправляет пакет **FIN** по протоколу TCP, и в этот момент состояние сокета меняется на `FIN_WAIT_1`。
2.  Получатель получает пакет **FIN** и возвращает пакет **ACK** с порядковым номером подтверждения, одновременно отправляя своему процессу завершающий символ EOF. В этот момент состояние сокета на стороне сервера меняется на `CLOSE_WAIT`, а состояние отправителя после получения **ACK** меняется на `FIN_WAIT_2`
3.  серверная прикладная программа обнаруживает необходимость закрытия сокета, то есть вызывает функцию close, отправляет на другой конец пакет **FIN** по протоколу TCP и изменяет состояние сокета на `LAST_ACK`；
4.  发起方接到 **FIN** 包后即发 **ACK** 确认包，同时 socket 状态更改为 `TIME_WAIT`。此时 server 端 socket 正常变为 `CLOSED`， 但客户端需等待 **2MSL**（Maximum Segment Lifetime 报文最大生存时间）后状态方变为 `CLOSED`。

> `TIME_WAIT` Цель состояния — предотвратить потерю **ACK** в конце передачи, когда принимающая сторона находится в состоянии `LAST_ACK` и повторно отправляет **FIN** по истечении времени ожидания. Таким образом, сторона, инициирующая закрытие соединения, переходит в состояние `TIME_WAIT` и при проведении стресс-тестирования часто находится в этом состоянии. Номер порта, используемый процессом, не может быть освобождён, что приводит к сбою при последующем установлении соединения.

На уровне протокола ядра можно решить проблему `TIME_WAIT` с помощью следующих двух параметров:

1.  `TIME_WAIT` Состояние можно использовать повторно, поэтому, даже если `TIME_WAIT` заполнит все порты, он не отклонит новый запрос

```
echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse 
```

1.  `TIME_WAIT` 尽快回收

```
echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle 
```

> tcp\_tw\_recycle 打开后能在很短的时间能将 `TIME_WAIT` 的端口回收（但是具体时间并未找到相应的资料，测试观察在1秒左右）。同时，打开加速回收或者允许重用，存在一定的问题，例如，发起方(client) 在发出最后一个 **ACK** 后立即被回收，而 **ACK** 丢失，接受方超时重发 **FIN**，恰好此时发起方使用刚才的端口建立起新的连接，那它将收到一个 **FIN**，从而可能引发异常被动关闭。

与 `TIME_WAIT` 相对应的是 `CLOSE_WAIT` 问题，被动关闭的情况下，已经接收到 **FIN**，但是还没有发送自己的 **FIN** 的时刻，连接处于 `CLOSE_WAIT` 状态。正常情况下 `CLOSE_WAIT` 状态时间很短。如果出现大量的 `CLOSE_WAIT`，是某种情况下对方关闭了连接，但是接收方忙于读或者写，没有关闭连接导致。在代码实现的时候需要判断 socket，一旦 read 返回 0，断开连接，read 返回负，检查一下 errno，如果不是 AGAIN，也断开连接。

1.  Кумулятивное положительное подтверждение с повторной передачей
2.  Управление потоком (раздвижное окно)
3.  Контроль перегрузки

> 2 и 3 необязательны ! Правда ?!

**Управление блокировкой** и **управление потоком** в протоколе TCP/IP предназначены для обеспечения надёжности и эффективности передачи данных по сети, но их цели и способы реализации различаются.

**Управление с помощью блокировки** предназначено для предотвращения блокировки сети, то есть ситуации, когда поток данных в сети слишком велик, что приводит к снижению производительности сети или потере данных. Цель управления с помощью блокировки — ограничить скорость передачи данных отправителем, чтобы предотвратить блокировку сети. Алгоритмы управления с помощью блокировки в протоколе TCP включают медленное начало работы, предотвращение блокировки, быструю повторную передачу и быстрое восстановление и т. д.

**流量控制**是为了防止接收方无法处理发送方发送的数据，即当接收方处理速度较慢时，导致数据丢失或缓存溢出。流量控制的目的是通过限制发送方的数据发送速率，以避免接收方无法处理数据。TCP 协议中的流量控制使用了滑动窗口机制，接收方通过发送窗口大小告诉发送方可以接收的数据量，发送方根据接收方的窗口大小来控制发送速率。

Таким образом, контроль перегрузки и контроль потока предназначены для обеспечения надёжности и эффективности передачи данных по сети, но контроль перегрузки предназначен для предотвращения перегрузки сети, а контроль потока — для предотвращения невозможности обработки данных получателем.

*   Не стоит безоговорочно верить тому, что пишут в интернете. Они друг друга копируют, всё перевирают, выдают желаемое за действительное.

Например, автоматическая настройка буфера: не устанавливайте SNDBUF/RCVBUF, если только вы не хотите уменьшить их

*   [Из личного опыта: о том, что происходит во время ожидания — Чэнь Цзы](https://coolshell.cn/articles/22263.html)
*   [Как справиться с состоянием ОЖИДАНИЯ TCP на загруженных серверах Linux](https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux)
*   [TCP 的那些事儿（上）- 陈皓](https://coolshell.cn/articles/11564.html)
*   [TCP 的那些事儿（下）- 陈皓](https://coolshell.cn/articles/11609.html)

![](http://blog.gerryyang.com/assets/images/202306/ipv4header.jpg)

![](http://blog.gerryyang.com/assets/images/202306/tcpheader.jpg)

![](http://blog.gerryyang.com/assets/images/202205/network_address.png)

[Сетевой адрес](https://en.wikipedia.org/wiki/Network_address) — это идентификатор [узла](https://en.wikipedia.org/wiki/Node_(networking)) или [хоста](https://en.wikipedia.org/wiki/Host_(networking)) в [телекоммуникационной сети](https://en.wikipedia.org/wiki/Telecommunications_network). Сетевые адреса предназначены для [уникального идентификации](https://en.wikipedia.org/wiki/Unique_identifier) в сети, хотя в некоторых сетях используются [локальные](https://en.wikipedia.org/wiki/Link-local_address), [частные](https://en.wikipedia.org/wiki/Private_network) или [локально администрируемые адреса](https://en.wikipedia.org/wiki/Locally_administered_address), которые могут быть неуникальными. Специальные сетевые адреса используются в качестве [широковещательных](https://en.wikipedia.org/wiki/Broadcast_address) или [многоадресных](https://en.wikipedia.org/wiki/Multicast_address). Они тоже не являются уникальными.

В некоторых случаях сетевые узлы могут иметь более одного сетевого адреса. Например, каждый [контроллер сетевого интерфейса](https://en.wikipedia.org/wiki/Network_interface_controller) может быть идентифицирован уникальным образом. Кроме того, поскольку протоколы часто [многоуровневые](https://en.wikipedia.org/wiki/Abstraction_layer), в любом конкретном сетевом интерфейсе или узле может быть более одного сетевого адреса протокола, а в любой сети может использоваться более одного типа сетевого адреса.

Сетевые адреса могут быть плоскими адресами, не содержащими информации о местоположении узла в сети (например, [MAC-адрес](https://en.wikipedia.org/wiki/MAC_address)), или могут содержать структурную или иерархическую информацию для [маршрутизации](https://en.wikipedia.org/wiki/Routing) (например, [IP-адрес](https://en.wikipedia.org/wiki/IP_address)).

*   https://en.wikipedia.org/wiki/Network\_address

sockaddr\_in
------------

```
struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
}; 
```

*   https://man7.org/linux/man-pages/man7/ip.7.html

хостент
-------

`hostent`Структура определяется в `<netdb.h>` следующим образом:

```
struct hostent {
    char  *h_name;            /* official name of host */
    char **h_aliases;         /* alias list */
    int    h_addrtype;        /* host address type */
    int    h_length;          /* length of address */
    char **h_addr_list;       /* list of addresses */
}
#define h_addr h_addr_list[0] /* for backward compatibility */ 
```

Членами структуры hostent являются:

*   `h_name` Официальное название принимающей стороны.
*   `h_aliases` Массив альтернативных имен для хоста, заканчивающийся нулевым указателем.
*   `h_addrtype` Тип адреса; всегда `AF_INET` или `AF_INET6` в настоящее время.
*   `h_length` Длина адреса в байтах.
*   `h_addr_list` Массив указателей на сетевые адреса хоста (в сетевом порядке байтов), завершающийся нулевым указателем.
*   `h_addr` Первый адрес в списке h\_addr\_list для обратной совместимости.
    
*   https://man7.org/linux/man-pages/man3/gethostbyname.3.html

аддринфо
--------

`addrinfo`Структура , используемая `getaddrinfo()` , содержит следующие поля:

```
struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    socklen_t        ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
}; 
```

*   https://man7.org/linux/man-pages/man3/getaddrinfo.3.html

SO\_SNDBUF

Устанавливает или получает максимальный буфер отправки сокета в байтах. **Ядро удваивает это значение** (чтобы освободить место для накладных расходов на ведение бухгалтерского учета), когда оно задается с помощью setsockopt(2), и это удвоенное значение возвращается getsockopt(2). Значение по умолчанию устанавливается в `/proc/sys/net/core/wmem_default` файле, а максимально допустимое значение устанавливается в `/proc/sys/net/core/wmem_max` файле. **Минимальное (удвоенное) значение для этого параметра равно 2048**.

SO\_RCVBUF

Устанавливает или получает максимальный буфер приема сокета в байтах. **Ядро удваивает это значение** (чтобы освободить место для накладных расходов на ведение бухгалтерского учета), когда оно задается с помощью setsockopt(2), и это удвоенное значение возвращается getsockopt(2). Значение по умолчанию устанавливается в `/proc/sys/net/core/rmem_default` файле, а максимально допустимое значение устанавливается в `/proc/sys/net/core/rmem_max` файле. **Минимальное (удвоенное) значение для этого параметра равно 256**.

> NOTES: Linux assumes that half of the send/receive buffer is used for internal kernel structures; thus the sysctls are twice what can be observed on the wire.

*   https://man7.org/linux/man-pages/man7/socket.7.html
*   [Understanding set/getsockopt SO\_SNDBUF size doubles](https://stackoverflow.com/questions/2031109/understanding-set-getsockopt-so-sndbuf-size-doubles)

connect
-------

connect - initiate a connection on a socket

неблокирующее подключение
-------------------------

解释1:

Для неблокирующего подключения вам следует выполнить следующие действия:

*   создайте сокет с помощью `socket(..., SOCK_NONBLOCK, ...)`
*   начните подключение с `connect(fd, ...)`
*   если возвращаемое значение не является ни `0` ни `EINPROGRESS`, то прерывание с ошибкой
*   подождите, пока `fd` не подаст сигнал о готовности к выводу
*   проверьте состояние розетки с помощью `getsockopt(fd, SOL_SOCKET, SO_ERROR, ...)`
*   Выполнено

Никаких циклов - если только вы не хотите их обрабатывать `EINTR`.

Если сначала запускается клиент, вы должны увидеть ошибку `ECONNREFUSED` на последнем шаге. Если это произошло, закройте сокет и начните с самого начала.

解释2:

Ситуация: вы настраиваете неблокирующий сокет и выполняете функцию connect(), которая возвращает -1/EINPROGRESS или -1/EWOULDBLOCK. Вы выбираете() сокет для записи. Это возвращает значение, как только соединение будет успешно установлено или прервано. (Исключение: в некоторых старых версиях Ultrix функция select() не заметит сбой до истечения 75-секундного тайм-аута.)

Вопрос: Что вы делаете после того, как select() возвращает возможность записи? Соединение не удалось? Если да, то почему?

Если соединение не удалось установить, причина скрывается в параметре so\_error в сокете. В современных системах можно увидеть so\_error с помощью функции getsockopt(,,SO\_ERROR,,), но это не переносимый способ — на самом деле, функция getsockopt() может привести к сбою в старых системах. Другой способ увидеть so\_error — это ошибка при передаче данных: любая попытка чтения или записи данных в сокете вернёт -1/so\_error.

Иногда у вас есть данные, которые нужно немедленно записать в соединение. Тогда вы можете просто записать() эти данные. Если функция connect() не сработала, об этом сообщит функция write(), обычно с правильным значением errno функции connect(). Это решение, которое я предложил для IRC в 1990 году. К сожалению, в некоторых системах при определённых обстоятельствах функция write() заменяет старое значение errno на EPIPE, поэтому вы теряете информацию.

Другой вариант — read(fd, &ch, 0). Если connect() завершилась успешно, вы получите возвращаемое значение 0, за исключением Solaris, где вы получите -1/EAGAIN. Если connect() завершилась неудачно, вы должны получить правильное значение errno из-за ошибки. Фатальный недостаток: в Linux вы всегда получите 0.

…

*   https://man7.org/linux/man-pages/man2/connect.2.html
*   [Linux, сокеты, неблокирующее подключение](https://stackoverflow.com/questions/17769964/linux-sockets-non-blocking-connect)
*   [Неблокирующие соединения с BSD-сокетами](https://cr.yp.to/docs/connect.html)
*   https://blog.csdn.net/nphyez/article/details/10268723

Отправить
---------

send, sendto, sendmsg - отправлять сообщение по сокету

> Описание

Системные вызовы `send()`, `sendto()` и `sendmsg()` используются для передачи сообщения в другой сокет.

Вызов `send()` может использоваться только в том случае, если сокет находится в подключённом состоянии (то есть известен получатель). Единственное различие между `send()` и `write(2)` заключается в наличии флагов. При нулевом значении аргумента флагов `send()` эквивалентен `write(2)`.

*   https://man7.org/linux/man-pages/man2/send.2.html
*   [Асинхронная отправка сокета в Linux](https://stackoverflow.com/questions/5633226/asynchronous-socket-send-on-linux)

recv
----

recv, recvfrom, recvmsg — получение сообщения из сокета

> Описание

Вызовы `recv()`, `recvfrom()` и `recvmsg()` используются для получения сообщений из сокета. Они могут использоваться для приема данных как через сокеты **без установления соединения**, так и через сокеты, **ориентированные** на подключение.

Единственное различие между `recv()` и `read(2)` заключается в наличии флагов. При нулевом аргументе флагов `recv()` обычно эквивалентен `read(2)` (но см. примечания).

Кроме того, следующий вызов `recv(sockfd, buf, len, flags);` эквивалентен `recvfrom(sockfd, buf, len, flags, NULL, NULL);`

Все три вызова возвращают длину сообщения при успешном завершении. **Если сообщение слишком длинное и не помещается в предоставленный буфер, лишние байты могут быть отброшены в зависимости от типа сокета, из которого получено сообщение.**

Если в сокете нет доступных сообщений, вызовы receive ожидают поступления сообщения, если только сокет не является неблокирующим (см. `fcntl(2)`), в этом случае возвращается значение `-1` и **errno** устанавливается в **EAGAIN** или **EWOULDBLOCK**. Вызовы receive обычно возвращают все доступные данные в пределах запрошенного объёма, а не ждут поступления всего запрошенного объёма.

Приложение может использовать `select(2)`, `poll(2)` или `epoll(7)` для определения того, когда на сокет поступает больше данных.

*   https://man7.org/linux/man-pages/man2/recv.2.html
*   [Каково максимальное значение len для recv / recvfrom](https://stackoverflow.com/questions/62433052/what-is-the-maximum-len-to-recv-recvfrom)

выберите
--------

select, pselect, FD\_CLR, FD\_ISSET, FD\_SET, FD\_ZERO — синхронное мультиплексирование ввода-вывода

```
int select(int nfds,
            fd_set *restrict readfds,
            fd_set *restrict writefds,
            fd_set *restrict exceptfds,
            struct timeval *restrict timeout); 
```

> Описание

ВНИМАНИЕ: `select()` может отслеживать только номера файловых дескрипторов, которые меньше `FD_SETSIZE` (`1024`) — неоправданно низкий предел для многих современных приложений, — и это ограничение не изменится. Вместо этого все современные приложения должны использовать `poll(2)` или `epoll(7)`, которые не имеют этого ограничения.

`select()` позволяет программе отслеживать несколько файловых дескрипторов, ожидая, пока один или несколько файловых дескрипторов не станут «готовыми» для выполнения какого-либо класса операций ввода-вывода (например, возможен ввод). Файловый дескриптор считается готовым, если можно выполнить соответствующую операцию ввода-вывода (например, `read(2)` или достаточно маленький `write(2)`) без блокировки.

```
nfds

This argument should be set to the highest-numbered file descriptor in any of the three sets, plus 1.  The indicated file descriptors in each set are checked, up to this limit (but see BUGS).

BUGS

POSIX allows an implementation to define an upper limit, advertised via the constant FD_SETSIZE, on the range of file descriptors that can be specified in a file descriptor set.  The Linux kernel imposes no fixed limit, but the glibc implementation makes fd_set a fixed-size type, with FD_SETSIZE defined as 1024, and the FD_*() macros operating according to that limit.  To monitor file descriptors greater than 1023, use poll(2) or epoll(7) instead. 
```

*   https://man7.org/linux/man-pages/man2/select.2.html

опрос
-----

```
#include <poll.h> 
int poll(struct pollfd *fds, nfds_t nfds, int timeout); 
```

`poll()` выполняет аналогичную `select(2)` задачу: ожидает, когда один из набора файловых дескрипторов будет готов к выполнению операций ввода-вывода. Специфичный для Linux `epoll(7)` API выполняет аналогичную задачу, но предлагает дополнительные функции, которых нет в `poll()`.

Набор отслеживаемых файловых дескрипторов указывается в аргументе `fds`, который представляет собой **массив структур** следующей формы:

```
struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
}; 
```

Вызывающий объект должен указать количество элементов в `fds` массиве в `nfds`.

*   https://man7.org/linux/man-pages/man2/poll.2.html

getsockopt
----------

getsockopt, setsockopt - получение и установка параметров для сокетов

> Описание

Функции getsockopt() и setsockopt() управляют параметрами сокета, на который указывает файловый дескриптор sockfd. Параметры могут существовать на нескольких уровнях протокола; они всегда присутствуют на самом верхнем уровне сокета.

*   https://man7.org/linux/man-pages/man2/getsockopt.2.html

getaddrinfo
-----------

```
int getaddrinfo(const char *restrict node,
                const char *restrict service,
                const struct addrinfo *restrict hints,
                struct addrinfo **restrict res); 
```

При наличии `node` и `service`, которые идентифицируют интернет-хост и службу, `getaddrinfo()` возвращает одну или несколько структур `addrinfo`, каждая из которых содержит интернет-адрес, который можно указать при вызове `bind(2)` или `connect(2)`. Функция `getaddrinfo()` объединяет функциональность, предоставляемую функциями `gethostbyname(3)` и `getservbyname(3)`, в единый интерфейс, но, в отличие от последних, `getaddrinfo()` является **реентерабельной и позволяет программам устранять зависимости между IPv4 и IPv6**.

`getaddrinfo()` используется для преобразования доменного имени, например **stackoverflow.com**, в IP-адрес, например **69.59.196.211**.

Для получения дополнительной информации вот как это работает в деталях: [Что делает getaddrinfo?](https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/)

TL;DR: он проходит через `/etc/nsswitch.conf` и использует все перечисленные там модули для определения пути. Обычно это `hosts: files myhostname dns`: когда он наконец доходит до модуля DNS, он динамически загружает эту библиотеку, а затем выполняет поиск DNS, просматривая `/etc/hosts` и `/etc/resolv.conf`.

测试代码：

https://wandbox.org/permlink/lLxsF1NqXamWodoF

```
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h> 
int main(void)
{
  struct addrinfo* addr;
  int result = getaddrinfo("google.com", NULL, NULL, &addr);
  if (result != 0) {
    printf("Error from getaddrinfo: %s\n", gai_strerror(result));
    return 1;
  }
  struct sockaddr_in* internet_addr = (struct sockaddr_in*) addr->ai_addr;
  printf("google.com is at: %s\n", inet_ntoa(internet_addr->sin_addr));
  freeaddrinfo(addr);
  return 0;
} 
```

```
$./a.out
google.com is at: 172.217.163.46 
```

*   https://man7.org/linux/man-pages/man3/getaddrinfo.3.html
*   [Как getaddrinfo() выполняет поиск DNS?](https://stackoverflow.com/questions/2157592/how-does-getaddrinfo-do-dns-lookup)
*   [Что делает getaddrinfo?](https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/)

gethostbyname - имя хоста
-------------------------

```
#include <stdio.h>
#include <netdb.h> 
int main()
{
    struct hostent *lh = gethostbyname("localhost");
    if (lh) {
        puts(lh->h_name);
        printf("%u.%u.%u.%u\n", lh->h_addr_list[0][0],
                        lh->h_addr_list[0][1],
                        lh->h_addr_list[0][2],
                        lh->h_addr_list[0][3]);
    } else {
        herror("gethostbyname");
    }
}
/*
localhost
127.0.0.1
*/ 
```

*   https://man7.org/linux/man-pages/man3/gethostbyname.3.html

получитеимя
-----------

```
#include <sys/socket.h> 
int getpeername(int sockfd, struct sockaddr *restrict addr,
                socklen_t *restrict addrlen); 
```

`getpeername()` возвращает адрес однорангового узла, подключённого к сокету `sockfd`, в буфере, на который указывает `addr`. Аргумент `addrlen` должен быть инициализирован для указания объёма памяти, на который указывает `addr`. При возврате он содержит фактический размер возвращаемого имени (в байтах). Если предоставленный буфер слишком мал, имя будет усечено.

Возвращаемый адрес усекается, если предоставленный буфер слишком мал; в этом случае `addrlen` вернёт значение, превышающее то, которое было передано в вызове.

*   https://man7.org/linux/man-pages/man2/getpeername.2.html

эполл
-----

Не включайте `EPOLLOUT` до тех пор, пока вы не получите `EAGAIN` в результате попытки записи, и удалите его, когда вы успешно запишете байты в сокет. **По сути, это означает, что сокет всегда доступен для записи, пока в буфере отправки сокета есть место.**

У вас есть два потока данных - **ввод** и **вывод**.

Вы ожидаете **ввода**, включив `EPOLLIN` в флаги. Если по возвращении из `epoll_wait(2)` этот флаг не установлен, значит, либо какое-то событие произошло в другом сокете, либо в этом сокете произошло какое-то другое событие. Оставьте флаг в событиях, если только вы не получили ошибку (то есть вас по-прежнему интересует ввод в сокете).

Вам не нужно ждать **вывода** (поскольку это ваше действие), вы просто записываете данные в сокет, но если вы переполните буфер отправки сокета, вы получите `EAGAIN` от `send(2)` или `write(2)`. В этом случае вы начинаете ждать, пока вывод станет возможным (ядро опустошает буфер отправки сокета, освобождая место для отправки дополнительных данных), включая `EPOLLOUT`. Как только вы получите его, запишите ожидающие вывода байты в сокет, и если всё пройдёт успешно, удалите `EPOLLOUT` из событий.

Теперь `EPOLLET` указывает на **ожидание с триггером**, то есть ваше желаемое событие будет сигнализироваться только один раз при изменении состояния (например, от «нет ввода» к «есть ввод»). В этом режиме предполагается, что вы будете считывать входные байты в цикле, пока не получите `EAGAIN`.

*   https://man7.org/linux/man-pages/man7/epoll.7.html
*   https://stackoverflow.com/questions/13568858/epoll-wait-всегда устанавливает бит epollout

epoll\_ctl
----------

```
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
```

Аргумент `event` описывает объект, связанный с файловым дескриптором `fd`. Структура `epoll_event` определяется следующим образом:

```
typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;

struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
}; 
```

Элемент данных структуры `epoll_event` определяет данные, которые ядро должно сохранить, а затем вернуть (через `epoll_wait(2)`) при готовности этого файлового дескриптора.

Элемент `events` структуры epoll\_event представляет собой битовую маску, составленную из нуля или более следующих доступных типов событий:

*   `EPOLLIN`: Соответствующий файл доступен для `read(2)` операций.
*   `EPOLLOUT`: Соответствующий файл доступен для `write(2)` операций.
*   `EPOLLRDHUP (since Linux 2.6.17)`: Одноранговое соединение с потоковым сокетом закрыто или отключено при записи половины соединения. (Этот флаг особенно полезен для написания простого кода для обнаружения отключения однорангового соединения при использовании мониторинга с пороговым срабатыванием.)
*   `EPOLLPRI`: В дескрипторе файла возникло исключительное состояние. См. обсуждение POLLPRI в `poll(2)`.
*   `EPOLLERR`: Возникло условие ошибки для связанного файлового дескриптора. Это событие также регистрируется для конца записи канала, когда конец чтения был закрыт. `epoll_wait(2)`  всегда будет регистрировать это событие; нет необходимости устанавливать его в событиях при вызове `epoll_ctl()`.
*   `EPOLLHUP`: Произошло зависание связанного файлового дескриптора. `epoll_wait(2)`  всегда будет ожидать этого события; нет необходимости устанавливать его в событиях при вызове `epoll_ctl()`. Обратите внимание, что при чтении из канала, такого как канал или потоковый сокет, это событие просто указывает на то, что другой участник закрыл свой конец канала. Последующие чтения из канала вернут 0 (конец файла) только после того, как будут прочитаны все данные в канале.
*   `EPOLLET`: Запрашивает **срабатывание по границе** для связанного файлового дескриптора. **По умолчанию для epoll используется срабатывание по уровню**. См. `epoll(7)` для получения более подробной информации о срабатывании по границе и срабатывании по уровню. Этот флаг является **входным флагом** для поля `event.events` при вызове `epoll_ctl()`; он никогда не возвращается `epoll_wait(2)`.
*   `EPOLLONESHOT (since Linux 2.6.2)`: Запрашивает одноразовое уведомление для соответствующего файлового дескриптора. Это означает, что после события, уведомленного для файлового дескриптора с помощью `epoll_wait(2)`, файловый дескриптор отключается в списке интересов, и интерфейс epoll не будет сообщать о других событиях. Пользователь должен вызвать `epoll_ctl()` с `EPOLL_CTL_MOD`, чтобы повторно настроить (重装备装备) файловый дескриптор с новой маской события. Этот флаг является **флагом ввода** для `event.events` поля при вызове `epoll_ctl()`; он никогда не возвращается `epoll_wait(2)`.
*   EPOLLWAKEUP (начиная с Linux 3.5)
*   EPOLLEXCLUSIVE (начиная с Linux 4.5)

ссылаться:

*   https://man7.org/linux/man-pages/man2/epoll\_ctl.2.html
*   https://cloud.tencent.com/developer/article/1481046

Nagle 算法主要用来预防小分组的产生。在广域网上，大量 TCP 小分组极有可能造成网络的拥塞。Nagle 是针对每一个 TCP 连接的。它要求一个 TCP 连接上最多只能有一个未被确认的小分组。在该分组的确认到达之前不能发送其他小分组。TCP 会搜集这些小的分组，然后在之前小分组的确认到达后将刚才搜集的小分组合并发送出去。

Иногда необходимо отключить алгоритм Нагла, особенно в некоторых интерактивных операционных средах с высокими требованиями к задержке, где все небольшие группы данных должны быть отправлены как можно скорее. Можно программно отключить алгоритм Нагла с помощью опции `TCP_NODELAY` для отключения алгоритма Нагла.

> Алгоритм Нагла — это продукт своего времени, потому что в те времена пропускная способность сети была ограничена. А пропускная способность современных локальных и глобальных сетей намного выше, поэтому в современных стеках протоколов TCP/IP алгоритм Нагла по умолчанию отключен.

*   https://cloud.tencent.com/developer/article/1784570

Простая проверка
----------------

[EaseProbe](https://github.com/megaease/easeprobe) — это простой, автономный и лёгкий инструмент для проверки работоспособности/состояния, написанный на Go.

[Как преобразовать строку в IP-адрес и наоборот](https://stackoverflow.com/questions/5328070/how-to-convert-string-to-ip-address-and-vice-versa)
------------------------------------------------------------------------------------------------------------------------------------------------

Используйте `inet_ntop()` и `inet_pton()` в обратном порядке. Не используйте `inet_ntoa()`, `inet_aton()` и аналогичные, так как они устарели и не поддерживают ipv6.

```
// IPv4 demo of inet_ntop() and inet_pton()

struct sockaddr_in sa;
char str[INET_ADDRSTRLEN];

// store this IP address in sa:
inet_pton(AF_INET, "192.0.2.33", &(sa.sin_addr));

// now get it back and print it
inet_ntop(AF_INET, &(sa.sin_addr), str, INET_ADDRSTRLEN);

printf("%s\n", str); // prints "192.0.2.33" 
```

[Когда требуется параметр TCP SO\_LINGER (0)?](https://stackoverflow.com/questions/3757289/when-is-tcp-option-so-linger-0-required?newreg=6f6d760f75ec40cfa3b813ee7731b14e)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Обычно тайм-аут `SO_LINGER` устанавливается равным нулю, чтобы избежать большого количества подключений, находящихся в состоянии `TIME_WAIT` и потребляющих все доступные ресурсы сервера.

Когда TCP-соединение закрывается корректно, сторона, инициировавшая закрытие («активное закрытие»), оставляет соединение в `TIME_WAIT` на несколько минут. Поэтому, если ваш протокол предполагает, что сервер инициирует закрытие соединения, и включает в себя очень большое количество кратковременных соединений, он может быть подвержен этой проблеме.

Однако это не лучшая идея — `TIME_WAIT` существует не просто так (чтобы гарантировать, что случайные пакеты от старых подключений не будут мешать новым подключениям). Лучше переработать протокол так, чтобы клиент инициировал закрытие подключения, если это возможно.

*   [TCP/IP 概述 по 陈 陈](https://b23.tv/lBAsi98)
*   [Заметки Шуо Чена о стеке TCP / IP Linux](https://chenshuo.com/tcpip-study/)
*   https://github.com/chenshuo/tcpip-study
*   [Руководство Beej по сетевому программированию](https://beej.us/guide/bgnet/)
*   [LINUX — мультиплексирование ввода-вывода — SELECT, POLL и EPOLL](https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.ZAmnruxBw0Q)