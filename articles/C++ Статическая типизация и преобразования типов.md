# C++ | Статическая типизация и преобразования типов
Последнее обновление: 13.02.2023

С++ является статически типизированным языком программирования. То есть если мы определили для переменной какой-то тип данных, то в последующем мы этот тип изменить не сможем. Соответственно переменная может получить значения только того типа, который она представляет. Однако нередко возникает необходимость присвоить переменной значения каких-то других типов. И в этом случае применяются преобразования типов.

Ряд преобразований компилятор может производить неявно, то есть автоматически. Например:

```

```

Здесь переменная age представляет тип `unsigned int` и условно хранит возраст. Эта переменная инициализируется числом 25, а все целочисленные литералы без суффиксов по умолчанию представляют тип `int` (`signed int`). Но компилятор знает как преобразовать значение 25 к типу `unsigned int`, и каких-то проблем в данном случае не будет.

Но посмотрим на другой пример:

```

```

Здесь переменной age уже присваивается число -25 - отрицательное, в то время как тип переменной - `unsigned int` предполагает лишь использование положительных чисел. И в этом случае мы столкнемся с ошибкой компиляции. Например, вывод компилятора g++:

```
error: narrowing conversion of '-25' from 'int' to 'unsigned int' \[-Wnarrowing\]
```

### Примеры неявных преобразований

Рассмотрим, как выполняются некоторые базовые преобразования:

*   Переменной типа bool присваивается значение другого типа. В этом случае переменная получает false, если значение равно 0. Во всех остальных случаях переменная получает true.
    
    ```
    
    ```
    
*   Числовой или символьной переменной присваивается значение типа bool. В этом случае переменная получает 1, если значение равно true, либо получает 0, если присваиваемое значение равно false.
    
    ```
    
    ```
    
*   Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается.
    
    ```
    
    ```
    
*   Переменной, которая представляет тип с плавающей точкой, присваивается целое число. В этом случае, если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается.
    
    ```
    
    ```
    
*   Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона. В этом случае результатом будет остаток от деления по модулю. Например, тип unsigned char может хранить значения от 0 до 255. Если присвоить ему значение вне этого диапазона, то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений). Так, при присвоении значения -5 переменная типа unsigned char получит значение 251
    
    ```
    
    ```
    
*   Переменной знакового типа (signed) присваивается значение не из его диапазона. В этом случае результат не детерминирован. Программа может выдавать адекватный результат, а может работать некорректно.
    

### Преобразования в арифметических операциях

В арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип. Если же операнды имеют разные типы, то компилятор автоматически выбирает операнд с типом который имеет меньший диапазон значений и пытается его преобразовать в тип второго операнда, который имеет больший диапазон значений. С точки зрения преобразований в операциях типы можно расположить следующим образом в порядке приоритета (от более высокого к более низкому):

1.  long double
    
2.  double
    
3.  float
    
4.  unsigned long long
    
5.  long long
    
6.  unsigned long
    
7.  long
    
8.  unsigned int
    
9.  int
    

То есть, если в операции участвует число типа `float` и типа `long double`, то компилятор автоматически преобразует операнд типа `float` в тип `long double` (который в соответствии с вышеуказанным списком имеет более высокий приоритет).

Операнды типов `char, signed char, unsigned char, short` и `unsigned short` всегда при операциях преобразуются как минимум в тип `int`

Например, программист заработал за 8 часовой рабочий день 100,2$, рассчитаем его заработок за час:

```

```

Здесь переменная hours, которая представляет тип `int` и хранит количество часов, будет преобразована к "более приоритетному" типу `double`.

С одной стороны, это может показаться довольно удобно. С другой стороны, подобные преобразования могут привести к нежелательным результатам. Например:

```

```

Здесь в операции `n - x` число n будет преобразовываться к более приоритетному типу - `unsigned int`. Формально эта операция возвращает `5 - 8 = -3`. Но в нашем случае оба операнда и соответственно результат представляют тип `unsigned int`, поэтому в итоге результат равен `4294967293`.

### Опасные и безопасные преобразования

Те преобразования, при которых не происходит потеря информации, являются безопасными. Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью. В частности, это следующие цепочки преобразований:

bool -> char -> short -> int -> double -> long double

bool -> char -> short -> int -> long -> long long

unsigned char -> unsigned short -> unsigned int -> unsigned long

float -> double -> long double

Примеры безопасных преобразований:

```

```

Но также есть опасные преобразования. При подобных преобразованиях мы потенциально можем потерять точность данных. Как правило, это преобразования от типа с большей разрядностью к типу с меньшей разрядностью.

```

```

В данном случае переменным a и b присваивается значения, которые выходят за пределы диапазона допустимых значений для данных типов.

И в подобных примерах многое зависит от компилятора. В ряде случаев компиляторы при компиляции выдают предупреждение, тем не менее программа может быть успешно скомпилирована. В других случаях компиляторы не выдают никакого предупреждения. Собственно в этом и заключается опасность, что программа успешно компилируется, но тем не менее существует риск потери точности данных. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения.

Если речь идет об инициализации переменных, то, чтобы избежать опасных преобразований, когда может произойти потеря точности, рекомендуется использовать инициализацию в фигурных скобках:

```

```

В этом случае компилятор сгенерирует ошибку, и программа не скомпилируется.

### Явные преобразования типов

Для выполнения явных преобразований типов (explicit type conversion) применяется оператор static\_cast

Данный оператор преобразует значение в круглых скобках - `value` к типу, который указан в угловых скобках - `type`. Слово `static` в названии оператора отражает тот факт, что приведение проверяется статически, то есть во время компиляции.

Применение оператора `static_cast` указывает компилятору, что мы уверены, что в этом месте надо применить преобразование, поэтому даже при инициализации в фигурных скобках компилятор не сгенерирует ошибку. Например, программист заработал за 8 часовой рабочий день 100,2$, рассчитаем его заработок за час, но в виде значения unsigned int:

```

```

Здесь выражение `static_cast<unsigned int>(sum/hours)` вычисляет значение выражения `sum/hours` (а оно будет представлять тип double), и затем преобразует его в тип `unsigned int`

Стоит отметить, что раньше во времена динозавров в С++ применялась операция преобразования, унаследованная от языка Си:

То есть перед преобразуемым значением в круглых скобках указывался тип, в который надо выполнить преобразование. Например, используем эту операцию в ранее приведенном коде:

```

```

Результат будет тот же. Однако в современном C++ эту операцию практически вытеснил оператор static\_cast.