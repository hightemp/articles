# Проектирование высокопроизводительных кэширующих решений с использованием Redis и Memcached / Хабр
![](https://habrastorage.org/getpro/habr/upload_files/102/0c4/42a/1020c442ace9a56123199c64f3a18a87.jpg)

_Привет, Хабр!_

Каждая **миллисекунда имеет значение**, кэширование стало безусловно важной частью проектирования высокопроизводительных приложений. Оптимизация скорости и доступности данных стала приоритетом для разработчиков, и кэширование является одним из наиболее эффективных способов достижения этой цели. **Redis** и **Memcached** играют занимают важную роль в этом процессе.

**Redis и Memcached** – два из самых популярных и мощных инструментов для реализации кэширования. Redis, изначально разработанный как _in-memory_ хранилище данных, позволяет эффективно хранить и быстро извлекать информацию в памяти, что делает его идеальным выбором для кэширования. Memcached, с другой стороны, специализируется исключительно на кэшировании данных и предоставляет _простой, но мощный способ_ ускорить доступ к данным.

Кратко об Redis и Memcached
---------------------------

1. **Redis** - это мощное _in-memory_ хранилище данных, которое является одним из самых популярных инструментов в мире кэширования и хранения данных. Он отличается высокой скоростью доступа и поддержкой широкого спектра структур данных, таких как строки, списки, множества и хеш-таблицы. Важной чертой Redis является его способность атомарно выполнять операции, что делает его идеальным для различных сценариев, включая кэширование, обработку очередей и даже управление счетчиками.

Redis также обладает гибкими возможностями конфигурации и репликации, что позволяет создавать высокодоступные и отказоустойчивые системы. Его популярность обусловлена также богатым экосистемным набором инструментов и библиотек, что делает его практически универсальным инструментом для многих сценариев.

_Redis часто используется для кэширования данных и ускорения операций с базой данных. Однако, не стоит ограничивать себя только этими сценариями. Redis - это настоящий Swiss Army Knife в мире хранения данных._

Подробнее о Redis можно прочитать и попробовать на их [сайте](https://redis.io/).

2\. **Memcached** - это еще один мощный инструмент для кэширования, который специализируется исключительно на in-memory кэшировании. В отличие от Redis, Memcached ориентирован только на хранение данных в памяти, и не предоставляет структур данных. Однако, это делает его невероятно быстрым и простым в использовании.

Memcached также поддерживает распределенное кэширование, что позволяет горизонтально масштабировать вашу систему при необходимости. Он широко используется для ускорения доступа к данным и обработки больших объемов запросов.

_Memcached - это чрезвычайно легковесный и простой инструмент. Если вам нужно быстро ускорить доступ к данным без сложной настройки, Memcached - это ваш выбор._

#### Сравнение Redis и Memcached

1.  **Преимущества и недостатки каждого решения**
    
    Redis:
    
    *   **Преимущества:**
        
        *   Поддержка разнообразных структур данных.
            
        *   Атомарные операции для множества сценариев.
            
        *   Гибкая конфигурация и репликация.
            
        *   Богатый экосистемный набор.
            
    *   **Недостатки:**
        
        *   Использует больше памяти по сравнению с Memcached.
            
        *   Сложнее в настройке и управлении.
            
    
    Memcached:
    
    *   **Преимущества:**
        
        *   Простота и легковесность.
            
        *   Высокая скорость доступа.
            
        *   Идеально подходит для базового кэширования.
            
    *   **Недостатки:**
        
        *   Ограничен только in-memory кэшированием.
            
        *   Не предоставляет сложных структур данных, таких как списки и хеш-таблицы.
            
2.  **Когда использовать Redis, а когда Memcached**
    
    *   Используйте **Redis**, когда вам нужны сложные структуры данных, расширенные возможности для обработки данных и готовность к сложной настройке.
        
    *   Используйте **Memcached**, когда требуется быстрое и легкое in-memory кэширование без лишних наворотов.
        

_Выбор между Redis и Memcached зависит от конкретных требований вашего проекта. Иногда даже комбинированный подход может быть наилучшим решением, чтобы достичь оптимальной производительности._

Проектирование высокопроизводительных кэширующих решений
--------------------------------------------------------

Архитектурное проектирование кэширующих решений является ключевым этапом в создании высокопроизводительных приложений. Эффективное разделение данных, управление кластерами и обеспечение отказоустойчивости являются фундаментальными аспектами этого процесса.

### 1\. Разделение кэшей по типам данных

Для достижения оптимальной производительности и эффективного использования кэширования необходимо разделить кэши по типам данных. Это позволит более точно управлять кэшированием для различных частей приложения. Рассмотрим пример этого процесса на практике.

#### Разделение кэшей в веб-приложении

Предположим, у вас есть веб-приложение, которое обрабатывает пользовательские запросы, включая авторизацию, профили пользователей и новостную ленту. Вы можете создать отдельные кэши для каждой из этих частей приложения. Например, вы можете иметь кэш для сеансов авторизации, который содержит информацию о пользователях, а также кэши для профилей пользователей и новостной ленты:

```
# Пример в Python использования Redis для кэширования профилей пользователейimport redis# Подключение к Redisredis_client = redis.StrictRedis(host='localhost', port=6379, db=0)# Функция для получения профиля пользователя с кэшированиемdef get_user_profile(user_id):    cache_key = f'user_profile:{user_id}'        # Попытка получения профиля из кэша    cached_profile = redis_client.get(cache_key)        if cached_profile:        return cached_profile.decode('utf-8')        # Если профиль отсутствует в кэше, получение данных из базы данных    profile_data = fetch_profile_from_database(user_id)        # Сохранение профиля в кэше с временем жизни    redis_client.setex(cache_key, 3600, profile_data)        return profile_data
```

### 2\. Кластеризация и репликация

Для обеспечения высокой доступности и масштабируемости кэшей необходимо использовать кластеризацию и репликацию. Кластеризация позволяет распределить кэши по нескольким серверам или узлам, что снижает нагрузку на один центральный сервер и увеличивает общую производительность.

#### Кластеризация Redis

Redis поддерживает кластеризацию с использованием разделения данных на слоты и автоматическим маршрутизацией запросов. Это позволяет создавать кластеры Redis с высокой доступностью и распределенным хранением данных.

```
# Пример настройки кластера Redis с помощью Pythonfrom rediscluster import RedisCluster# Конфигурация для кластера Rediscluster_nodes = [{'host': 'redis-node-1', 'port': 7000},                 {'host': 'redis-node-2', 'port': 7001},                 {'host': 'redis-node-3', 'port': 7002}]# Создание клиента RedisClusterredis_cluster = RedisCluster(startup_nodes=cluster_nodes, decode_responses=True)# Пример кэширования в кластере Redisdef cache_data(key, value):    redis_cluster.set(key, value)
```

#### Выбор правильной структуры данных

Redis предоставляет разнообразные структуры данных, что делает его мощным инструментом для кэширования данных разных типов:

*   **Строки (Strings):** Используются для хранения простых значений, таких как текстовые данные, числа или сериализованные объекты. Эффективно используют память и могут быть просто обновлены и заменены:
    
    ```
    # Кэширование строки в Redisredis_client.set("user:1:name", "John Doe")
    ```
    
*   **Списки (Lists):** Позволяют хранить упорядоченные последовательности элементов. Их можно использовать для хранения ленты действий или сообщений, что делает их полезными в социальных сетях или системах обработки событий:
    
    ```
    # Добавление элемента в список в Redisredis_client.lpush("news_feed:1", "New post added")
    ```
    
*   **Множества (Sets):** Поддерживают уникальные элементы без дублирования. Используются для хранения наборов данных, таких как теги или уникальные идентификаторы:
    
    ```
    # Добавление элементов в множество в Redisredis_client.sadd("tags:article:1", "technology", "programming")
    ```
    
*   **Хеш-таблицы (Hashes):** Позволяют хранить ассоциативные массивы с ключами и значениями. Хороши для хранения сложных объектов или записей с множеством полей:
    
    ```
    # Добавление данных в хеш-таблицу в Redisredis_client.hset("user:1", "name", "John Doe")
    ```
    

### Ключи и значения в Memcached

Memcached предоставляет более простую модель кэширования, где данные представлены ключами и значениями, но отсутствуют структуры данных, предоставляемые Redis.

*   **Ключи (Keys):** Эффективные идентификаторы, используемые для доступа к данным в Memcached. Важно выбирать ключи так, чтобы они были информативными и уникальными.
    
    _Пример:_
    
    ```
    # Использование ключа для доступа к данным в Memcachedmemcached_client.set("user:1:name", "John Doe")
    ```
    
*   **Значения (Values):** В Memcached значения обычно являются простыми строками или бинарными данными. Эффективность хранения и доступа к данным зависит от размера и структуры значений.
    
    _Пример:_
    
    ```
    # Сохранение значения в Memcachedmemcached_client.set("user:1:email", "john@example.com")
    ```
    

### Управление жизненным циклом кэша

#### 1\. Установка сроков хранения

Установка сроков хранения (TTL - Time To Live) для кэшированных данных позволяет контролировать, сколько времени данные будут актуальными в кэше. Это важно для предотвращения устаревания данных и избыточного использования памяти. Redis и Memcached предоставляют механизмы для установки TTL для кэшированных ключей:

```
# Установка срока хранения (TTL) для ключа в Redisredis_client.setex("user:1:profile", 3600, "John Doe Profile Data")
```

В этом примере, ключ `user:1:profile` будет храниться в кэше Redis в течение одного часа (3600 секунд), после чего он будет автоматически удален. Это помогает поддерживать актуальность данных в кэше.

#### 2\. Автоматическое удаление устаревших данных

Для обеспечения эффективности кэширования необходимо регулярно удалять устаревшие данные. Redis и Memcached предоставляют механизмы для автоматического удаления устаревших ключей:

```
# Использование Redis для автоматического удаления устаревших данных# Например, удалять ключи, которые не были запрошены в течение определенного периода времени.redis_client.config_set('inactive-keys-expires', 3600)  # Удалить ключи, не запрошенные в течение часа
```

```
# В Memcached ключи могут быть автоматически удалены при достижении TTL# Например, ключи удаляются автоматически после истечения установленного TTL.
```

Автоматическое удаление устаревших данных позволяет поддерживать чистоту кэша и освобождать память для новых данных.

Оптимизация производительности
------------------------------

Одной из ключевых задач в проектировании высокопроизводительных кэширующих решений является минимизация запросов к бэкенду. Уменьшение нагрузки на бэкенд-серверы способствует увеличению производительности и снижению задержек в приложении.

#### 1\. Кэширование запросов и ответов

Одной из эффективных стратегий является кэширование не только ответов от бэкенда, но и самих запросов. Это позволяет избежать выполнения одних и тех же запросов к бэкенду многократно, особенно в случаях, когда запросы затратны по времени или ресурсам:

```
# Пример кэширования запроса в Redisdef get_data_from_backend(request):    # Генерируем уникальный ключ для запроса на основе параметров запроса    cache_key = "request:" + hashlib.md5(request).hexdigest()        # Проверяем, есть ли результат запроса в кэше    cached_result = redis_client.get(cache_key)        if cached_result is not None:        return cached_result        # Если результат не найден в кэше, выполняем запрос к бэкенду    result = perform_backend_request(request)        # Сохраняем результат запроса в кэше с TTL    redis_client.setex(cache_key, 3600, result)  # Например, кэш на 1 час        return result
```

#### 2\. Стратегии сброса кэша

Стратегии сброса кэша определяют, когда и какие данные следует удалять из кэша. Это важно для обеспечения актуальности данных в кэше и предотвращения отображения устаревших данных клиентам. Существует несколько стратегий сброса кэша:

*   **Время жизни (TTL):** Устанавливается срок хранения для кэшированных данных, после которого они автоматически удаляются из кэша, как было рассмотрено в предыдущем разделе.
    
*   **Событийное сброс:** Кэшированные данные могут быть сброшены при наступлении определенных событий, таких как обновление данных на бэкенде или изменение связанных данных.
    
*   **Инвалидация:** Это стратегия, при которой данные считаются недействительными, когда происходят определенные изменения на бэкенде. Например, при изменении записи данных на бэкенде, соответствующий ключ в кэше становится недействительным.
    

_Инвалидация кэша в Redis:_

```
# Пример инвалидации кэша при обновлении данных на бэкендеdef update_data_on_backend(data):    # Обновление данных на бэкенде    perform_backend_update(data)        # Инвалидация соответствующих ключей в кэше    invalidate_cache("data:1")
```

### Поддержание целостности данных

Вам нужно гарантировать, что данные, находящиеся в кэше, всегда актуальны и соответствуют данным в источнике.

#### 1\. Консистентность между кэшем и источником данных

Чтобы поддерживать консистентность между кэшем и источником данных, необходимо обеспечить согласованность при обновлении источника данных и кэша. Для этого можно использовать следующие стратегии:

*   **Инвалидация кэша:** При каждом обновлении данных на бэкенде, соответствующие кэшированные данные следует инвалидировать или удалить из кэша. Это гарантирует, что клиенты получат актуальные данные при следующем запросе:
    
    ```
    # При обновлении данных на бэкенде инвалидируем соответствующий кэшdef update_data_on_backend(data):    perform_backend_update(data)        # Инвалидация соответствующего кэша    invalidate_cache("data:1")
    ```
    
*   **Избежание потери данных:** При чтении данных из кэша перед выполнением запроса к бэкенду, вы можете проверить, актуальные ли они. Если данные устарели (например, TTL истек), выполните запрос к бэкенду, обновите кэш и верните актуальные данные клиенту:
    
    ```
    # Проверка данных в кэше перед запросом к бэкендуdef get_data(request):    cache_key = generate_cache_key(request)    cached_data = cache.get(cache_key)        if cached_data is not None:        return cached_data        # Если данные устарели, выполните запрос к бэкенду и обновите кэш    fresh_data = fetch_data_from_backend(request)    cache.set(cache_key, fresh_data, ttl=3600)  # Например, кэш на 1 час        return fresh_data
    ```
    

#### 2\. Работа с транзакциями и многозадачностью

При работе с кэширующими решениями, особенно в многозадачной среде, важно учитывать транзакции и согласованность данных. В случае использования кэширования в распределенных системах, убедитесь, что операции с кэшем и бэкендом выполняются атомарно, чтобы избежать проблем с согласованностью данных.

*   **Транзакции в Redis:** Redis поддерживает транзакции, которые позволяют группировать несколько команд в одну атомарную операцию. Это полезно, например, при обновлении нескольких ключей в кэше и бэкенде одновременно:
    
    ```
    with redis_client.pipeline() as pipe:    # Начало транзакции    pipe.multi()        # Выполнение нескольких команд внутри транзакции    pipe.set("user:1:name", "John Doe")    pipe.hset("user:1", "email", "john@example.com")        # Завершение транзакции    pipe.execute()
    ```
    
*   **Многозадачность:** При работе в многозадачной среде, например, веб-сервере, убедитесь, что операции с кэшем и бэкендом правильно синхронизированы, чтобы избежать гонок и конфликтов.
    

### Мониторинг и настройка производительности

#### 1\. Использование метрик Redis и Memcached

Мониторинг производительности Redis и Memcached основан на сборе и анализе метрик. Эти метрики предоставляют информацию о нагрузке, использовании памяти, времени ответа и других параметрах, которые помогают выявить проблемы и улучшить производительность.

*   **Время ответа (Response Time):** Метрика, которая измеряет, сколько времени занимает выполнение запросов к кэшу. Высокое время ответа может указывать на проблемы с производительностью.
    
*   **Использование CPU и памяти:** Мониторинг нагрузки на сервер Redis или Memcached помогает выявить узкие места и оптимизировать ресурсы.
    
*   **Количество запросов и хитов:** Отслеживание количества запросов и попаданий в кэш помогает оценить эффективность кэширования и оценить, насколько хорошо кэш справляется с нагрузкой.
    
*   **Потерянные соединения и ошибки:** Мониторинг потерянных соединений и ошибок помогает выявить проблемы в сети или конфигурации.
    

_Использование метрик в Redis:_

```
# Получение метрик из Redisresponse_time = redis_client.info("stats")["avg_latency"]cpu_usage = redis_client.info("cpu")["used_cpu_sys"]memory_usage = redis_client.info("memory")["used_memory"]requests = redis_client.info("stats")["total_commands_processed"]cache_hits = redis_client.info("stats")["keyspace_hits"]
```

#### 2\. Оптимизация конфигурации

*   **Параметры памяти:** Убедитесь, что вы выделили достаточно памяти для Redis и Memcached, чтобы хранить кэшированные данные без фрагментации памяти.
    
*   **Кэширование данных:** Тщательно выбирайте, какие данные кэшировать, и установите разумные TTL для данных, чтобы избежать переполнения кэша и хранения устаревших данных.
    
*   **Кластеризация:** В случае высокой нагрузки рассмотрите возможность использования кластера Redis или Memcached для распределенного хранения данных и балансировки нагрузки.
    
*   **Параметры сети:** Оптимизируйте параметры сети, такие как ограничение на количество одновременных соединений и настройки тайм-аутов, чтобы обеспечить стабильное соединение с кэш-серверами.
    

_Оптимизация конфигурации Redis:_

```
# Пример настройки параметров в Redismaxmemory = "2GB"  # Максимальный объем памяти для Redismaxmemory-policy = "allkeys-lru"  # Политика удаления данных при переполнении памятиcluster-enabled = yes  # Включение поддержки кластера
```

Защита и безопасность
---------------------

#### 1\. Защита от несанкционированного доступа

Для этого следует рассмотреть следующие меры:

*   **Аутентификация:** Включите аутентификацию на серверах Redis и Memcached, чтобы требовать аутентификацию перед выполнением любых операций. Используйте сильные пароли или механизмы аутентификации, предоставляемые Redis и Memcached.
    
    _Включение аутентификации в Redis:_
    
    ```
    # В файле redis.conf установите пароль
    requirepass your_password
    
    ```
    
*   **Настройка сетевого доступа:** Ограничьте доступ к серверам Redis и Memcached только для доверенных IP-адресов или подсетей. Это можно сделать через настройки брандмауэра или конфигурации самого кэш-сервера.
    
    _Настройка сетевого доступа в Redis:_
    
    ```
    # В файле redis.conf установите разрешенные IP-адреса
    bind 127.0.0.1
    
    ```
    

#### 2\. Роли и разрешения

Роли и разрешения позволяют управлять доступом к разным функциям и данным в кэш-серверах. Это помогает разграничивать права доступа и уменьшать риски несанкционированного использования.

*   **Роли доступа:** Создайте роли, которые определяют, какие операции разрешены для каждого пользователя или приложения. Например, можно создать роль только для чтения данных из кэша и роль для записи.
    
*   **Разрешения:** Дайте разрешения на выполнение определенных команд или операций кэш-сервера только для определенных ролей. Это позволит точно настроить права доступа.
    

_Настройка ролей и разрешений в Redis:_

```
# Создание роли только для чтения данных
redis-cli ACL SETUSER read_only_user NOVERBS +GET +MGET

# Создание роли для записи данных
redis-cli ACL SETUSER write_user NOVERBS +SET +MSET

```

### Защита от атак

#### 1\. Предотвращение DDoS-атак

DDoS-атаки могут быть направлены на сервера Redis и Memcached, что может привести к перегрузке и отказу в обслуживании. Для предотвращения DDoS-атак следует рассмотреть следующие меры:

*   **Ограничение доступа:** Ограничьте доступ к серверам Redis и Memcached только с доверенных IP-адресов или подсетей.
    
*   **Мониторинг нагрузки:** Установите мониторинг нагрузки и уведомления, чтобы быстро выявлять аномальные нагрузки и атаки.
    
*   **Использование брандмауэра:** Настройте брандмауэр, чтобы фильтровать нежелательный трафик до достижения кэш-серверов.
    

#### 2\. Защита от инъекций и других уязвимостей

Инъекции, такие как инъекции SQL или команд, а также другие уязвимости могут быть использованы для атак на приложения, которые используют Redis и Memcached. Для защиты от таких угроз следует:

*   **Валидация и санитария данных:** Всегда валидируйте и санитаризируйте данные, поступающие от клиентов, прежде чем передавать их в кэш-сервер.
    
*   **Используйте параметризованные запросы:** Если вы используете кэширование для запросов к базе данных, предпочтительно использовать параметризованные запросы, чтобы избежать инъекций SQL.
    
*   **Обновляйте кэш безопасно:** При обновлении кэша, особенно в многозадачных средах, обеспечьте безопасность операций и избегайте гонок.
    

Примеры использования Redis и Memcached
---------------------------------------

#### Кэширование данных в веб-приложениях

Кэширование данных в веб-приложениях с использованием Redis и Memcached может значительно улучшить производительность и снизить нагрузку на базу данных. Давайте рассмотрим огромный пример кода, как это можно реализовать в Python с использованием библиотеки Redis-Py.

```
import redis# Подключение к серверу Redisredis_client = redis.StrictRedis(host='localhost', port=6379, db=0)def get_data_from_cache_or_db(user_id):    # Генерируем ключ для кэширования    cache_key = f"user_data:{user_id}"        # Попытка получить данные из кэша    cached_data = redis_client.get(cache_key)        if cached_data is not None:        return cached_data.decode('utf-8')    else:        # Если данных нет в кэше, получаем их из базы данных        data_from_db = fetch_data_from_database(user_id)                # Сохраняем данные в кэше с TTL (например, на 1 час)        redis_client.setex(cache_key, 3600, data_from_db)                return data_from_dbdef fetch_data_from_database(user_id):    # Эмулируем запрос к базе данных    # В реальном приложении это будет обращение к реальной БД    # Здесь можно выполнить SQL-запрос или использовать ORM    data = f"Data for user {user_id} from database"    return data# Пример использования функцииuser_id = 123user_data = get_data_from_cache_or_db(user_id)print(user_data)
```

Этот код показывает, как можно кэшировать данные пользователей, чтобы ускорить доступ к ним в веб-приложении. Когда данные запрашиваются, сначала они ищутся в кэше Redis, и если их нет, то они извлекаются из базы данных и сохраняются в кэше для последующего использования.

#### Ускорение операций с базой данных

Redis и Memcached также могут использоваться для ускорения операций с базой данных. Они могут служить как кэш-слои, уменьшая нагрузку на базу данных. Рассмотрим огромный пример кода, как это можно реализовать в Python с использованием библиотеки Redis-Py.

```
import redisimport time# Подключение к серверу Redisredis_client = redis.StrictRedis(host='localhost', port=6379, db=0)def get_data_from_database(user_id):    # Эмулируем запрос к базе данных    # В реальном приложении это будет обращение к реальной БД    # Здесь можно выполнить SQL-запрос или использовать ORM    print(f"Fetching data for user {user_id} from database...")    time.sleep(2)  # Эмуляция задержки при запросе к базе данных    data = f"Data for user {user_id} from database"    return datadef get_data(user_id):    # Генерируем ключ для кэширования    cache_key = f"user_data:{user_id}"        # Попытка получить данные из кэша    cached_data = redis_client.get(cache_key)        if cached_data is not None:        print(f"Data for user {user_id} found in cache.")        return cached_data.decode('utf-8')    else:        # Если данных нет в кэше, получаем их из базы данных        data_from_db = get_data_from_database(user_id)                # Сохраняем данные в кэше с TTL (например, на 5 минут)        redis_client.setex(cache_key, 300, data_from_db)                return data_from_db# Пример использования функцииuser_id = 123user_data = get_data(user_id)print(user_data)
```

Этот код демонстрирует, как Redis может использоваться для кэширования данных из базы данных, что уменьшает нагрузку на базу данных и ускоряет операции чтения данных.

#### Распределенные вычисления и обработка задач

Redis может быть использован для распределенных вычислений и обработки задач с использованием его встроенных структур данных, таких как очереди (Redis Queue). Давайте рассмотрим огромный пример кода, как это можно реализовать в Python с использованием библиотеки RQ (Redis Queue).

```
import redisfrom rq import Queuefrom worker import Worker# Подключение к серверу Redisredis_client = redis.StrictRedis(host='localhost', port=6379, db=0)# Создание очередиqueue = Queue(connection=redis_client)def perform_task(task_data):    # Эмулируем выполнение задачи    print(f"Performing task: {task_data}")    # В реальном приложении здесь будет реальная обработка задачи# Добавление задачи в очередьtask_data = "Some task data"queue.enqueue(perform_task, task_data)# Создание и запуск рабочего процесса для обработки задачworker = Worker([queue], connection=redis_client)worker.work()
```

Этот код иллюстрирует, как Redis Queue (RQ) может быть использован для создания распределенной системы обработки задач, где задачи добавляются в очередь и обрабатываются асинхронно в рабочих процессах.

### Заключение

Redis и Memcached - это мощные инструменты, которые могут значительно улучшить производительность и надежность ваших приложений. Однако для их успешной реализации необходимо тщательное проектирование, оптимизация и обеспечение безопасности. Надеемся, что данная статья стала для вас ценным ресурсом и поможет вам мастерски использовать Redis и Memcached в ваших проектах. Не забывайте обновлять и совершенствовать свои навыки, чтобы оставаться на переднем крае разработки.

Еще больше, про высокопроизводительные системы вы сможете узнать на курсе [Highload Architect](https://otus.pw/2Abd/) от OTUS. В рамках запуска курса будут проводиться бесплатные занятия про [индексы в БД](https://otus.pw/HzWz/) и [Greenplum в высоконагруженных системах](https://otus.pw/RWBx/), которые вы можете посетить абсолютно бесплатно, пройдя простую регистрацию.