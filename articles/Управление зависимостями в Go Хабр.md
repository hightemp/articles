# Управление зависимостями в Go / Хабр
Уровень сложностиПростой

Время на прочтение7 мин

Количество просмотров9.4K

![](https://habrastorage.org/webt/ku/2a/iu/ku2aiubwsepxuhreqd5tuzea4qo.jpeg)

Одна из основных фич Go это система управления зависимостями. В начале своего пути Go полагался на **GOPATH**, что иногда вызывало сложности и ограничения для разработчиков. Однако с появлением **Go Modules** в Go версии 1.11, ситуация изменилась. Go Modules представили более гибкий инструмент для управления зависимостями, позволяя более эффективно управлять библиотеками и их версиями.

Go Modules был введен в Go с версии 1.11 как официальная система управления зависимостями. Она позволяет автоматически загружать зависимости, управлять версиями, и облегчает совместную работу.

  

### Шаги для создания нового модуля:

Для начала работы с Go Modules, первым шагом является создание нового модуля.

Выполнением команды `go mod init [module-path]` в корневой директории вашего проекта мы создаем модуль. `[module-path]` — это путь, который обычно представляет собой URL репозитория, где будет размещаться ваш модуль (например, _github.com/username/projectname_). Эта команда создаст файл go.mod в вашем проекте.

После инициализации, файл go.mod будет содержать только имя модуля и версию Go.  
Пример:

```
     module github.com/username/projectname     go 1.15
```

Когда вы импортируете пакеты в вашем коде и запускаете `go build` или `go test`, Go автоматически добавит эти зависимости в файл go.mod. Каждая зависимость будет указана с определенной версией.

### Структура файла go.mod

Файл _go.mod_ имеет несколько ключевых компонентов:

**1\. Module Path:**  
Заявляет имя модуля, который соответствует базовому URL репозитория.

**2\. Go Version:**  
Указывает минимальную версию Go, необходимую для модуля.

**3\. Require:**  
Описывает зависимости модуля. Содержит имена модулей и их версии. Пример:

```
     require (       github.com/some/dependency v1.2.3       github.com/another/dependency v0.1.0     )
```

**4\. Replace:**  
Используется для замены зависимости другой версией или местоположением. Это полезно при работе с локальными копиями зависимостей или при необходимости обойти проблемы с определенными версиями.

Пример:

```
replace github.com/some/dependency => ../local/path
```

**5\. Exclude:**  
Позволяет исключить определенные версии зависимостей. Это может быть необходимо, если известно, что определенная версия зависимости несовместима или содержит ошибки.

Пример:

```
exclude github.com/some/dependency v1.2.4
```

**6\. Indirect Dependencies:**  
В разделе `require` могут также появляться зависимости со словом // indirect. Это означает, что эти зависимости не используются напрямую вашим кодом, но требуются для зависимостей, которые вы используете.

### Управление зависимостями

Управление зависимостями в Go с использованием Go Modules включает в себя добавление, обновление и удаление зависимостей. Эти действия выполняются через командную строку с помощью утилиты командной строки Go.

**Добавление зависимостей**

Сначала нужно импортировать пакет, который вы хотите использовать, в ваш Go файл. Go Modules автоматически обнаружит необходимые зависимости при выполнении команд сборки или тестирования.

Когда вы запускаете `go build`, `go test` или `go run`, Go автоматически ищет импортированные пакеты, которых нет в текущем модуле, и добавляет их в файл go.mod.

Это также генерирует файл go.sum, который содержит хеши для проверки целостности зависимостей.

Можно также явно добавить зависимость, используя команду `go get [package]@version`. Например, `go get github.com/google/go-cmp@v0.5.0` добавит указанную версию пакета go-cmp от Google.

**Обновление зависимостей**

Чтобы обновить определенную зависимость до новой версии, используйте `go get [package]@version`. Например, `go get github.com/google/go-cmp@v0.6.0`.

Чтобы обновить все зависимости до последних версий, используйте `go get -u`.  
Эта команда проверит все зависимости и обновит их до последних версий, совместимых с вашими текущими версиями.

Используйте `go get -u=patch`, чтобы обновить все зависимости до последних патч-версий, не меняя мажорных и минорных версий.

**Удаление зависимостей**

Просто удалите использование зависимости из вашего кода.

После удаления кода, выполните **go mod tidy**. Эта команда удалит неиспользуемые зависимости из вашего файла go.mod и обновит файл go.sum.  
`go mod tidy` проверяет, какие пакеты действительно используются в вашем проекте, и удаляет записи о ненужных зависимостях.

Go использует систему семантического версионирования ([Semantic Versioning, SemVer](https://semver.org/)) для управления версиями своих модулей.

### Семантическое версионирование (SemVer)

SemVer следует формату **MAJOR.MINOR.PATCH** (например, \`2.3.4\`), где:  
— _MAJOR_ версия увеличивается, когда делаются несовместимые изменения API.  
— _MINOR_ версия увеличивается при добавлении новой функциональности, совместимой с предыдущими версиями.  
— _PATCH_ версия увеличивается при исправлении ошибок, совместимом с предыдущими версиями.

Cовместимость версий в SemVer определяется увеличением MAJOR версии. Это означает, что модули должны быть взаимозаменяемы в пределах одной и той же основной версии.

### Версионирование в Go Modules

Версии v0 и v1 обрабатываются как начальные и стабильные версии соответственно. v0 версии часто означают, что API может меняться, в то время как v1 указывает на стабильность API.

Для версий v2 и выше, Go требует, чтобы путь модуля включал версию. Например, _github.com/user/module/v2_. Это позволяет одновременно поддерживать несколько мажорных версий модуля.

Существуют специальные версии для коммитов — Pseudo-versions, они еще не помечены как релизы. Они используются для указания зависимости на конкретный коммит и выглядят как `v0.0.0-yyyymmddhhmmss-abcdefabcdef`.

Go Modules использует [алгоритм MVS](https://www.researchgate.net/figure/A-description-of-the-MVS-algorithm_fig4_303563963) для определения, какие версии зависимостей использовать. MVS всегда выбирает минимальную из возможных версий, что приводит к большей стабильности и предсказуемости сборки.

_При добавлении новой зависимости, Go автоматически выберет последнюю стабильную версию (если не указано иное)._

### Разрешение конфликтов зависимостей в Go Modules

Часто конфликты зависимостей возникают, когда различные части вашего проекта или его зависимости требуют разных версий одного и того же пакета. В Go Modules для разрешения таких конфликтов используется несколько механизмов:

### Минимальная версия выбора (Minimal Version Selection, MVS):

Это основной алгоритм в Go Modules, который определяет, какая версия зависимости будет использоваться. MVS всегда выбирает минимальную версию зависимости, которая удовлетворяет всем требованиям проекта и его зависимостей. Это помогает избежать конфликтов и упрощает управление зависимостями.

Вы можете явно указать версию зависимости в файле go.mod, чтобы управлять, какая версия должна использоваться.

Если возникают конфликты, связанные с определенными версиями, вы можете использовать директиву replace в go.mod, чтобы заменить одну зависимость другой. Это полезно, например, при работе с форками зависимостей, локальными копиями или при временном решении конфликтов, связанных с определенными версиями.

В некоторых случаях, обновление или удаление конфликтующей зависимости может быть лучшим решением. Это может потребовать изменения кода, чтобы он соответствовал новой версии зависимости, или отказа от использования определенных библиотек.

### Управление косвенными зависимостями

Косвенные зависимости — это те зависимости, которые необходимы вашим прямым зависимостям, но не указаны явно в вашем файле go.mod.

Go Modules автоматически учитывает косвенные зависимости, обеспечивая, чтобы все необходимые пакеты были доступны и совместимы. Команда `go list -m all` позволяет просмотреть все прямые и косвенные зависимости вашего проекта.

Когда вы обновляете прямые зависимости, косвенные зависимости также могут быть обновлены, если это необходимо для совместимости. Если косвенная зависимость вызывает конфликт, его можно разрешить, явно добавив прямую зависимость с нужной версией в `go.mod`.

### Использование замены зависимостей (Replace directive)

Если вы работаете над двумя модулями одновременно, один из которых зависит от другого, можно использовать `replace`, чтобы указать на локальную версию зависимого модуля.

```
replace example.com/old/module => ../local/module
```

Если в используемой библиотеке обнаружен баг, и вы хотите временно использовать исправленную версию до ее официального обновления, `replace` позволяет указать на вашу версию.

`replace example.com/buggy/module => example.com/fixed/module v1.0.1`  
Если вы используете форк официального репозитория, `replace` позволяет перенаправить зависимость на ваш форк.

```
replace example.com/original/module => github.com/yourusername/module-fork v1.2.3
```

`replace` часто используется как временное решение и рекомендуется обновлять зависимости до официальных версий, как только это становится возможным.  
Если другие проекты зависят от вашего модуля, директивы `replace`, указанные в вашем go.mod, не будут применяться.

### Работа с приватными репозиториями

По умолчанию, Go пытается получить зависимости через публичные URL, что не работает для приватных репозиториев.

Создайте SSH-ключ, если у вас его еще нет, и добавьте его в ваш аккаунт на сервере Git.  
Настройте Git для использования SSH-ключа для определенных доменов.  
Пример конфигурации ~/.ssh/config:

```
     Host github.com       IdentityFile ~/.ssh/your_private_key
```

На платформах, таких как GitHub или GitLab, можно использовать персональные токены доступа. Настройте URL репозитория так, чтобы он включал ваш токен.

```
https://your-token@github.com/yourusername/yourrepo.git
```

Если ваш проект зависит от приватных модулей, каждый разработчик или среда сборки должны быть настроены на использование аутентификации для доступа к этим репозиториям.

  

### Организация кода в модулях

Структурируйте код так, чтобы каждый модуль представлял одну функциональность или сервис. Это облегчает управление зависимостями и обновлениями.

К примеру если у вас есть проект для работы с базой данных и веб-API, разделите их на два модуля: _myproject/db_ и _myproject/web_.

Определите, какие функции и структуры являются частью публичного API вашего модуля. Это упрощает поддержку и обновления модуля.

```
   // публичная функция   func ExportedFunc() {}   // приватная функция   func unexportedFunc() {}
```

Используйте короткие и понятные имена. Избегайте общих названий, таких как _util_ или _helper_, так как они могут привести к неструктурированному коду.  
К пример вместо `util` используйте `jsonutil` или `httputil` для более конкретного описания.

Старайтесь минимизировать количество зависимостей в вашем модуле. Это уменьшает сложность и увеличивает совместимость модуля.

### Использование частных репозиториев

Настройте переменные среды GOPRIVATE, GONOPROXY, и GONOSUMDB для указания частных репозиториев, которые не должны использовать публичный прокси и суммы проверок.

```
   export GOPRIVATE="github.com/mycompany/*"
```

Настройте аутентификацию для доступа к вашим частным репозиториям, например, с помощью git credentials или токенов доступа.

### Интеграция с системами непрерывной интеграции (CI/CD)

Настройте CI для автоматического выполнения тестов при каждом коммите или пулл-реквесте.  
Пример .gitlab-ci.yml:

```
   stages:
     - test

   test:
     script:
       - go test ./...
```

Используйте инструменты для статического анализа кода и линтинга, такие как [golint](https://github.com/golang/lint) или [staticcheck](https://staticcheck.dev/).

Настройте CD для автоматического развертывания вашего приложения после успешных тестов и проверок кода.

Для облегчения развертывания можно использовать докер и контейнеризацию вашего приложения, к примеру можно сделать так:

```
   FROM golang:1.15
   WORKDIR /app
   COPY . .
   RUN go build -o myapp
   CMD ["./myapp"]
```

  

Заключение
----------

Go Modules только упрощает процесс разработки и повышает его эффективность за счет обеспечения лучшего контроля версий, упрощения управления зависимостями и автоматизации многих процессов.