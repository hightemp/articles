# Указатели в C++ / Ravesli
На [**уроке №10**](https://ravesli.com/urok-10-peremennye-initsializatsiya-i-prisvaivanie-v-s/) мы узнали, что переменная — это название кусочка памяти, который содержит значение.

Оператор адреса &
-----------------

При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение, которое мы присваиваем переменной, сохраняется по этому адресу в памяти. Например:

При выполнении этого стейтмента процессором, выделяется часть оперативной памяти. В качестве примера предположим, что переменной `b` присваивается ячейка памяти под номером 150. Всякий раз, когда программа встречает переменную `b` в выражении или в стейтменте, она понимает, что для того, чтобы получить значение — ей нужно заглянуть в ячейку памяти под номером 150.

Хорошая новость — нам не нужно беспокоиться о том, какие конкретно адреса памяти выделены для определенных переменных. Мы просто ссылаемся на переменную через присвоенный ей идентификатор, а компилятор конвертирует это имя в соответствующий адрес памяти. Однако этот подход имеет некоторые ограничения, которые мы обсудим на этом и следующих уроках.

**Оператор адреса** `&` позволяет узнать, какой адрес памяти присвоен определенной переменной. Всё довольно просто:

|  | 

#include <iostream>

int  main()

{

int  a  \=  7;

std::cout  <<  a  <<  '\\n';  // выводим значение переменной a

std::cout  <<  &a  <<  '\\n';  // выводим адрес памяти переменной a

return  0;

}



 |

Результат на моем компьютере:

`7  
0046FCF0`

**_Примечание:_** Хотя оператор адреса выглядит так же, как [**оператор побитового И**](https://ravesli.com/urok-45-pobitovye-operatory/), отличить их можно по тому, что оператор адреса является [**унарным оператором**](https://ravesli.com/urok-17-operatory-v-s/), а оператор побитового И — бинарным оператором.

Оператор разыменования \*
-------------------------

**Оператор разыменования** `*` позволяет получить значение по указанному адресу:

|  | 

#include <iostream>

int  main()

{

int  a  \=  7;

std::cout  <<  a  <<  '\\n';  // выводим значение переменной a

std::cout  <<  &a  <<  '\\n';  // выводим адрес переменной a

std::cout  <<  \*&a  <<  '\\n';  /// выводим значение ячейки памяти переменной a

return  0;

}



 |

Результат на моем компьютере:

`7  
0046FCF0  
7`

**_Примечание:_** Хотя оператор разыменования выглядит так же, как и оператор умножения, отличить их можно по тому, что оператор разыменования — унарный, а оператор умножения — бинарный.

Указатели
---------

Теперь, когда мы уже знаем об операторах адреса и разыменования, мы можем поговорить об указателях.

**Указатель** — это переменная, значением которой является адрес ячейки памяти. Указатели объявляются точно так же, как и обычные переменные, только со звёздочкой между типом данных и идентификатором:

|  | 

int  \*iPtr;  // указатель на значение типа int

double  \*dPtr;  // указатель на значение типа double

int\*  iPtr3;  // корректный синтаксис (допустимый, но не желательный)

int  \*  iPtr4;  // корректный синтаксис (не делайте так)

int  \*iPtr5,  \*iPtr6;  // объявляем два указателя для переменных типа int



 |

Синтаксически язык C++ принимает объявление указателя, когда звёздочка находится рядом с типом данных, с идентификатором или даже посередине. Обратите внимание, эта звёздочка не является оператором разыменования. Это всего лишь часть синтаксиса объявления указателя.

Однако, при объявлении нескольких указателей, звёздочка должна находиться возле каждого идентификатора. Это легко забыть, если вы привыкли указывать звёздочку возле типа данных, а не возле имени переменной. Например:

|  | 

int\*  iPtr3,  iPtr4;  // iPtr3 - это указатель на значение типа int, а iPtr4 - это обычная переменная типа int!



 |

По этой причине, при объявлении указателя, рекомендуется указывать звёздочку возле имени переменной. Как и обычные переменные, указатели не инициализируются при объявлении. Содержимым неинициализированного указателя является обычный мусор.  

Присваивание значений указателю
-------------------------------

Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть адресом. Для получения адреса переменной используется оператор адреса:

|  | 

int  value  \=  5;

int  \*ptr  \=  &value;  // инициализируем ptr адресом значения переменной



 |

Приведенное выше можно проиллюстрировать следующим образом:

![](https://ravesli.com/wp-content/uploads/2017/09/img_pointer2.jpg)

Вот почему указатели имеют такое имя: `ptr` содержит адрес значения переменной `value`, и, можно сказать, `ptr` _указывает_ на это значение.

Еще очень часто можно увидеть следующее:

|  | 

#include <iostream>

int  main()

{

int  value  \=  5;

int  \*ptr  \=  &value;  // инициализируем ptr адресом значения переменной

std::cout  <<  &value  <<  '\\n';  // выводим адрес значения переменной value

std::cout  <<  ptr  <<  '\\n';  // выводим адрес, который хранит ptr

return  0;

}



 |

Результат на моем компьютере:

`003AFCD4  
003AFCD4`

Тип указателя должен соответствовать типу переменной, на которую он указывает:

|  | 

int  iValue  \=  7;

double  dValue  \=  9.0;

int  \*iPtr  \=  &iValue;  // ок

double  \*dPtr  \=  &dValue;  // ок

iPtr  \=  &dValue;  // неправильно: указатель типа int не может указывать на адрес переменной типа double

dPtr  \=  &iValue;  // неправильно: указатель типа double не может указывать на адрес переменной типа int



 |

Следующее не является допустимым:

Это связано с тем, что указатели могут содержать только адреса, а целочисленный [**литерал**](https://ravesli.com/urok-36-literaly-magicheskie-chisla/) `7` не имеет адреса памяти. Если вы все же сделаете это, то компилятор сообщит вам, что он не может преобразовать целочисленное значение в целочисленный указатель.

Язык C++ также не позволит вам напрямую присваивать адреса памяти указателю:

|  | 

double  \*dPtr  \=  0x0012FF7C;  // не ок: рассматривается как присваивание целочисленного литерала



 |

Оператор адреса возвращает указатель
------------------------------------

Стоит отметить, что оператор адреса `&` не возвращает адрес своего операнда в качестве литерала. Вместо этого он возвращает указатель, содержащий адрес операнда, тип которого получен из аргумента (например, адрес переменной типа int передается как адрес указателя на значение типа int):

|  | 

#include <iostream>

#include <typeinfo>

int  main()

{

int  x(4);

std::cout  <<  typeid(&x).name();

return  0;

}



 |

Результат выполнения программы:

`int *`  

Разыменование указателей
------------------------

Как только у нас есть указатель, указывающий на что-либо, мы можем его разыменовать, чтобы получить значение, на которое он указывает. Разыменованный указатель — это содержимое ячейки памяти, на которую он указывает:

|  | 

#include <iostream>

int  main()

{

int  value  \=  5;

std::cout  <<  &value  <<  std::endl;  // выводим адрес value

std::cout  <<  value  <<  std::endl;  // выводим содержимое value

int  \*ptr  \=  &value;  // ptr указывает на value

std::cout  <<  ptr  <<  std::endl;  // выводим адрес, который хранится в ptr, т.е. &value

std::cout  <<  \*ptr  <<  std::endl;  // разыменовываем ptr (получаем значение на которое указывает ptr)

return  0;

}



 |

Результат:

`0034FD90  
5  
0034FD90  
5`

Вот почему указатели должны иметь тип данных. Без типа указатель не знал бы, как интерпретировать содержимое, на которое он указывает (при разыменовании). Также, поэтому и должны совпадать тип указателя с типом переменной. Если они не совпадают, то указатель при разыменовании может неправильно интерпретировать биты (например, вместо типа double использовать тип int).

Одному указателю можно присваивать разные значения:

|  | 

int  value1  \=  5;

int  value2  \=  7;

int  \*ptr;

ptr  \=  &value1;  // ptr указывает на value1

std::cout  <<  \*ptr;  // выведется 5

ptr  \=  &value2;  // ptr теперь указывает на value2

std::cout  <<  \*ptr;  // выведется 7



 |

Когда адрес значения переменной присвоен указателю, то выполняется следующее:

   `ptr` — это то же самое, что и `&value`;

   `*ptr` обрабатывается так же, как и `value`.

Поскольку `*ptr` обрабатывается так же, как и `value`, то мы можем присваивать ему значения так, как если бы это была обычная переменная. Например:

|  | 

int  value  \=  5;

int  \*ptr  \=  &value;  // ptr указывает на value

\*ptr  \=  7;  // \*ptr - это то же самое, что и value, которому мы присвоили значение 7

std::cout  <<  value;  // выведется 7



 |

Разыменование некорректных указателей
-------------------------------------

Указатели в языке C++ по своей природе являются небезопасными, а их неправильное использование — один из лучших способов получить сбой программы.

При разыменовании указателя, программа пытается перейти в ячейку памяти, которая хранится в указателе и извлечь содержимое этой ячейки. По соображениям безопасности современные операционные системы (ОС) запускают программы в песочнице для предотвращения их неправильного взаимодействия с другими программами и для защиты стабильности самой операционной системы. Если программа попытается получить доступ к ячейке памяти, не выделенной для нее операционной системой, то ОС сразу завершит выполнение этой программы.

Следующая программа хорошо иллюстрирует вышесказанное. При запуске вы получите сбой (попробуйте, ничего страшного с вашим компьютером не произойдет):

|  | 

#include <iostream>

void  foo(int  \*&p)

{

}

int  main()

{

int  \*p;  // создаем неинициализированный указатель (содержимым которого является мусор)

foo(p);  // вводим компилятор в заблуждение, будто бы собираемся присвоить указателю корректное значение

std::cout  <<  \*p;  // разыменовываем указатель с мусором

return  0;

}



 |

Размер указателей
-----------------

Размер указателя зависит от архитектуры, на которой скомпилирован [**исполняемый файл**](https://ravesli.com/urok-3-vvedenie-v-razrabotku-programmnyh-produktov/): 32-битный исполняемый файл использует 32-битные адреса памяти. Следовательно, указатель на 32-битном устройстве занимает 32 бита (4 байта). С 64-битным исполняемым файлом указатель будет занимать 64 бита (8 байт). И это вне зависимости от того, на что указывает указатель:

|  | 

char  \*chPtr;  // тип char занимает 1 байт

int  \*iPtr;  // тип int занимает 4 байта

struct  Something

{

int  nX,  nY,  nZ;

};

Something \*somethingPtr;

std::cout  <<  sizeof(chPtr)  <<  '\\n';  // выведется 4

std::cout  <<  sizeof(iPtr)  <<  '\\n';  // выведется 4

std::cout  <<  sizeof(somethingPtr)  <<  '\\n';  // выведется 4



 |

Как вы можете видеть, размер указателя всегда один и тот же. Это связано с тем, что указатель — это всего лишь адрес памяти, а количество бит, необходимое для доступа к адресу памяти на определенном устройстве, — всегда постоянное.  

В чём польза указателей?
------------------------

Сейчас вы можете подумать, что указатели являются непрактичными и вообще ненужными. Зачем использовать указатель, если мы можем использовать исходную переменную?

Однако, оказывается, **указатели полезны в следующих случаях**:

   **_Случай №1:_ [Массивы](https://ravesli.com/urok-74-massivy-chast-1/) реализованы с помощью указателей**. Указатели могут использоваться для итерации по массиву.

   **_Случай №2:_ Они являются единственным способом динамического выделения памяти в C++**. Это, безусловно, самый распространенный вариант использования указателей.

   **_Случай №3:_ Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных**.

   **_Случай №4:_ Они могут использоваться для передачи одной функции в качестве параметра другой функции**.

   **_Случай №5:_ Они используются для достижения полиморфизма при работе с наследованием**.

   **_Случай №6:_ Они могут использоваться для представления одной [структуры](https://ravesli.com/urok-61-struktury/)/класса в другой структуре/классе, формируя, таким образом, целые цепочки**.

Указатели применяются во многих случаях. Не волнуйтесь, если вы многого не понимаете из вышесказанного. Теперь, когда мы разобрались с указателями на базовом уровне, мы можем начать углубляться в отдельные случаи, в которых они полезны, что мы и сделаем на последующих уроках.  

Заключение
----------

Указатели — это переменные, которые содержат адреса памяти. Их можно разыменовать с помощью оператора разыменования `*` для извлечения значений, хранимых по адресу памяти. Разыменование указателя, значением которого является мусор, приведет к сбою в вашей программе.

**_Совет_:** При объявлении указателя указывайте звёздочку возле имени переменной.

Тест
----

### Задание №1

Какие значения мы получим в результате выполнения следующей программы (предположим, что это 32-битное устройство, и тип short занимает 2 байта):

| 

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29



 | 

short  value  \=  7;  // &value = 0012FF60

short  otherValue  \=  3;  // &otherValue = 0012FF54

short  \*ptr  \=  &value;

std::cout  <<  &value  <<  '\\n';

std::cout  <<  value  <<  '\\n';

std::cout  <<  ptr  <<  '\\n';

std::cout  <<  \*ptr  <<  '\\n';

std::cout  <<  '\\n';

\*ptr  \=  9;

std::cout  <<  &value  <<  '\\n';

std::cout  <<  value  <<  '\\n';

std::cout  <<  ptr  <<  '\\n';

std::cout  <<  \*ptr<<  '\\n';

std::cout  <<  '\\n';

ptr  \=  &otherValue;

std::cout  <<  &otherValue  <<  '\\n';

std::cout  <<  otherValue  <<  '\\n';

std::cout  <<  ptr  <<  '\\n';

std::cout  <<  \*ptr  <<  '\\n';

std::cout  <<  '\\n';

std::cout  <<  sizeof(ptr)  <<  '\\n';

std::cout  <<  sizeof(\*ptr)  <<  '\\n';



 |

**Ответ №1**

Значения:

`0012FF60  
7  
0012FF60  
7`

`0012FF60  
9  
0012FF60  
9`

`0012FF54  
3  
0012FF54  
3`

`4  
2`

Краткое объяснение по поводу последней пары: `4` и `2`. 32-битное устройство означает, что размер указателя составляет 32 бита, но [**оператор sizeof**](https://ravesli.com/urok-41-sizeof-zapyataya-i-uslovnyj-ternarnyj-operator/#toc-0) всегда выводит размер в байтах: 32 бита = 4 байта. Таким образом, `sizeof(ptr)` равен `4`. Поскольку `ptr` является указателем на значение типа short, то `*ptr` является типа short. Размер short в этом примере составляет 2 байта. Таким образом, `sizeof(*ptr)` равен `2`.

### Задание №2

Что не так со следующим фрагментом кода:

|  | 

int  value  \=  45;

int  \*ptr  \=  &value;  // объявляем указатель и инициализируем его адресом переменной value

\*ptr  \=  &value;  // присваиваем адрес value для ptr



 |

**Ответ №2**

Последняя строка не скомпилируется. Рассмотрим эту программу детально.

В первой строке находится стандартное определение переменной вместе с инициализируемым значением. Здесь ничего особенного.

Во второй строке мы определяем новый указатель с именем `ptr` и присваиваем ему адрес переменной `value`. Помним, что в этом контексте звёздочка является частью синтаксиса объявления указателя, а не оператором разыменования. Так что и в этой строке всё нормально.

В третьей строке звёздочка уже является оператором разыменования, и используется для вытаскивания значения, на которое указывает указатель. Таким образом, эта строка говорит: «Вытаскиваем значение, на которое указывает `ptr` (целочисленное значение), и переписываем его на адрес этого же значения». А это уже какая-то чепуха — вы не можете присвоить адрес целочисленному значению!

Третья строка должна быть:

В вышеприведенной строке мы корректно присваиваем указателю адрес значения переменной.

Оценить статью:

![](https://ravesli.com/wp-content/plugins/wp-postratings/images/loading.gif)
 Загрузка...